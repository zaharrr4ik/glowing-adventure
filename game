import pygame
import random
import os
import sys
import time


class Character:
    def __init__(self, name, image_name, bright_image_name, speed):
        self.name = name
        self.image_name = image_name
        self.bright_image_name = bright_image_name
        self.speed = speed
        self.image = None
        self.bright_image = None
        self.rect = None
        self.highlighted = False


characters = [
    Character("Немецкий медик", "german_medic.png", "german_medic_bright.png", 5),
    Character("Военный Нигерии", "nigerian_soldier.png", "nigerian_soldier_bright.png", 2),
    Character("Русский военный", "russian_soldier.png", "russian_soldier_bright.png", 3),
]


class Camera:
    def __init__(self, width, height):
        self.dx = 0
        self.dy = 0
        self.width = width
        self.height = height

    def update(self, hero_pos):
        cell_size = 140
        self.dx = self.width // 2 - (hero_pos[0] * cell_size + cell_size // 2)
        self.dy = self.height // 2 - (hero_pos[1] * cell_size + cell_size // 2)


class Hero(pygame.sprite.Sprite):
    def __init__(self, image, pos):
        super().__init__()
        self.image = image
        self.rect = self.image.get_rect(topleft=pos)


def initialize_pygame():
    pygame.init()
    pygame.mixer.init()


def define_constants():
    global FPS, WHITE, BLACK, GRAY, YELLOW, RED, data_dir, sounds_dir, GAME_FONT
    FPS = 60
    WHITE = (255, 255, 255)
    BLACK = (0, 0, 0)
    GRAY = (50, 50, 50)
    YELLOW = (255, 255, 0)
    RED = (255, 0, 0)
    data_dir = os.path.join(os.path.dirname(__file__), "data")
    sounds_dir = os.path.join(os.path.dirname(__file__), "sounds")
    GAME_FONT = "comicsansms"


def draw_pixel_text(surface, text, font_size, x, y, color, font):
    font = pygame.font.SysFont(font, font_size)
    text_surface = font.render(text, True, color)
    text_rect = text_surface.get_rect(center=(x, y))
    blurred_surface = pygame.transform.scale(text_surface,
                                             (text_surface.get_width() * 2, text_surface.get_height() * 2))
    blurred_surface = pygame.transform.scale(blurred_surface, text_surface.get_size())
    surface.blit(blurred_surface, text_rect)


def input_box(screen, message, width, height, stars):
    font = pygame.font.Font(None, 36)
    input_rect = pygame.Rect((width - 600) // 2, (height - 50) // 2, 600, 50)
    color_active = pygame.Color('lightskyblue3')
    color_passive = pygame.Color('chartreuse4')
    active = False
    text = ''
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                quit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                active = input_rect.collidepoint(event.pos)
            if event.type == pygame.KEYDOWN:
                if active:
                    if event.key == pygame.K_RETURN:
                        running = False
                    elif event.key == pygame.K_BACKSPACE:
                        text = text[:-1]
                    else:
                        text += event.unicode

        screen.fill(BLACK)
        for star in stars:
            pygame.draw.circle(screen, WHITE, (star[0], star[1]), star[2])
        draw_pixel_text(screen, message, 48, width // 2, input_rect.top - 50, WHITE, font=GAME_FONT)
        color = color_active if active else color_passive
        pygame.draw.rect(screen, color, input_rect, 2)
        text_surface = font.render(text, True, color)
        screen.blit(text_surface, (input_rect.x + 5, input_rect.y + 5))
        pygame.display.flip()
    return text


def scale_image(image, scale_factor):
    new_width = int(image.get_width() * scale_factor)
    new_height = int(image.get_height() * scale_factor)
    return pygame.transform.scale(image, (new_width, new_height))


def create_cursor(cursor_image):
    try:
        if cursor_image is None:
            print("Warning: Cursor image not loaded correctly.")
            return None, None
        cursor_rect = cursor_image.get_rect()
        return cursor_image, cursor_rect
    except AttributeError as e:
        print(f"Error getting cursor rect: {e}")
        return None, None
    except Exception as e:
        print(f"An unexpected error occurred in create_cursor: {e}")
        return None, None


class MainScreen:
    def __init__(self, width, height):
        self.killed_enemies = 0
        self.total_enemies = 1
        self.volume_slider_rect = None
        self.settings_buttons = None
        self.aim_cursor_rect = None
        self.aim_cursor = None
        self.shot_sound = None
        self.reload_sound = None
        self.walk_sound = None
        self.click_sound = None
        self.character_images = None
        self.width = width
        self.height = height
        self.screen = pygame.display.set_mode((self.width, self.height))
        self.stars = []
        self.generate_stars(200)
        self.load_images()
        self.load_sounds()
        self.player_name = ""
        self.selected_character = None
        self.font = pygame.font.SysFont(None, 64)
        self.buttons = []
        self.volume = 0.5
        self.menu_opened_from_shooting_range = False
        self.previous_test_x = 0
        self.previous_test_y = 0
        self.previous_flipped_image = False
        self.test_x = 0
        self.test_y = 0
        self.flipped_image = False
        self.ammo = 0
        self.camera = Camera(self.width, self.height)
        self.saved_hero_pos = None
        self.saved_game_state = None
        self.game_results = []
        self.load_game_results()
        self.player_health = 10
        self.player_max_health = 10

    def run(self):
        if self.walk_sound and self.walk_sound.get_num_channels() > 0:
            self.walk_sound.stop()

        draw_pixel_text(self.screen, "Сквозь Миры", 150, self.width // 2, self.height // 3, YELLOW, font=GAME_FONT)
        pygame.display.flip()
        time.sleep(3)
        self.screen.fill(BLACK)
        self.show_story()
        self.show_menu_screen()
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        if self.selected_character:
                            self.show_menu_screen()
                        else:
                            self.show_menu_screen()
                    elif event.key == pygame.K_SPACE and self.selected_character is None:
                        self.choose_character()

            if self.selected_character:
                self.show_shooting_range()
            self.draw()
            pygame.display.flip()

        pygame.quit()
        sys.exit()

    def show_win_screen(self):
        pygame.mouse.set_visible(True)
        try:
            win_image = pygame.image.load(os.path.join(data_dir, "win.png")).convert_alpha()
            win_image = pygame.transform.scale(win_image, (self.width // 2, self.height // 2))
        except pygame.error:
            win_image = None

        button_width = 200
        button_height = 60
        button_padding = 40

        menu_button_rect = pygame.Rect(
            (self.width - button_width) // 2,
            self.height - button_height - button_padding,
            button_width,
            button_height
        )

        rating_button_rect = pygame.Rect(
            (self.width - button_width) // 2,
            self.height - button_height * 2 - button_padding * 2,
            button_width,
            button_height
        )

        running = True
        while running:
            self.screen.fill(BLACK)
            for star in self.stars:
                pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])

            if win_image:
                win_rect = win_image.get_rect(center=(self.width // 2, self.height // 3))
                self.screen.blit(win_image, win_rect)

            for rect, text, color in [
                (menu_button_rect, "Меню", (0, 200, 0)),
                (rating_button_rect, "Рейтинг", (200, 0, 0))
            ]:
                pygame.draw.rect(self.screen, color, rect, border_radius=10)
                text_surf = self.font.render(text, True, WHITE)
                text_rect = text_surf.get_rect(center=rect.center)
                self.screen.blit(text_surf, text_rect)

            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if menu_button_rect.collidepoint(event.pos):
                        if self.click_sound:
                            self.click_sound.play()
                        running = False
                        self.show_menu_screen()
                    elif rating_button_rect.collidepoint(event.pos):
                        if self.click_sound:
                            self.click_sound.play()
                        self.show_rating()

            pos = pygame.mouse.get_pos()
            for event in pygame.event.get():
                if event.type == pygame.MOUSEMOTION:
                    pygame.draw.circle(self.screen, WHITE, pos, 3)

    def save_game_result(self, kills, time_seconds):
        result = f"{self.player_name}\t{kills}\t{time_seconds}\t{time.time()}\n"

        self.game_results.append({
            "player": self.player_name,
            "kills": kills,
            "time": time_seconds,
            "timestamp": time.time()
        })

        self.game_results.sort(key=lambda x: (x['time'], -x['kills']))

        if len(self.game_results) > 10:
            self.game_results = self.game_results[:10]

        try:
            with open("results.txt", "w") as f:
                for res in self.game_results:
                    f.write(f"{res['player']}\t{res['kills']}\t{res['time']}\t{res['timestamp']}\n")
        except Exception as e:
            print(f"Error saving results: {e}")

    def load_game_results(self):
        self.game_results = []
        try:
            with open("results.txt", "r") as f:
                for line in f.readlines():
                    try:
                        parts = line.strip().split('\t')
                        if len(parts) == 4:
                            self.game_results.append({
                                "player": parts[0],
                                "kills": int(parts[1]),
                                "time": int(parts[2]),
                                "timestamp": float(parts[3])
                            })
                    except (ValueError, IndexError) as e:
                        print(f"Error parsing line: {line.strip()} - {e}")
        except FileNotFoundError:
            print("Results file not found, starting fresh")
        except Exception as e:
            print(f"Error loading results: {e}")

    def show_rating(self):
        rating_font = pygame.font.SysFont(GAME_FONT, 48)
        small_font = pygame.font.SysFont(GAME_FONT, 28)

        rating_surface = pygame.Surface((600, 500), pygame.SRCALPHA)
        rating_surface.fill((30, 30, 30, 200))

        title = rating_font.render("Топ игроков", True, WHITE)
        rating_surface.blit(title, (20, 20))

        place_colors = {
            0: (255, 215, 0),
            1: (192, 192, 192),
            2: (205, 127, 50)
        }

        y = 80
        for i, result in enumerate(self.game_results[:10]):
            color = place_colors.get(i, (150, 150, 150))
            time_str = f"{result['time'] // 60:02}мин {result['time'] % 60:02}сек"
            text = f"{i + 1}. {result['player'][:15]:<15} Уб: {result['kills']:2} Вр: {time_str}"
            text_surf = small_font.render(text, True, color)
            rating_surface.blit(text_surf, (20, y))
            y += 50

        rating_rect = rating_surface.get_rect(center=(self.width // 2, self.height // 2))

        running = True
        while running:
            self.screen.fill(BLACK)
            for star in self.stars:
                pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])

            self.screen.blit(rating_surface, rating_rect)

            pygame.display.flip()

            for event in pygame.event.get():
                if event.type in (pygame.QUIT, pygame.MOUSEBUTTONDOWN, pygame.KEYDOWN):
                    running = False

    def show_message(self, message):
        font = pygame.font.SysFont(None, 48)
        padding = 20
        frame_width = 600
        frame_height = 200
        frame_rect = pygame.Rect(self.width // 2 - frame_width // 2, self.height // 2 - frame_height // 2, frame_width,
                                 frame_height)

        pygame.draw.rect(self.screen, GRAY, frame_rect, border_radius=10)

        text_surface = font.render(message, True, WHITE)
        text_rect = text_surface.get_rect(center=(frame_rect.centerx, frame_rect.centery - 20))
        self.screen.blit(text_surface, text_rect)

        close_button_rect = pygame.Rect(frame_rect.right - 40, frame_rect.top + 10, 30, 30)
        pygame.draw.rect(self.screen, RED, close_button_rect, border_radius=15)
        close_button_text = font.render("X", True, WHITE)
        close_button_text_rect = close_button_text.get_rect(center=close_button_rect.center)
        self.screen.blit(close_button_text, close_button_text_rect)

        pygame.display.flip()

        waiting = True
        while waiting:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if close_button_rect.collidepoint(event.pos):
                        waiting = False

    def show_death_screen(self):
        try:
            death_image = pygame.image.load(os.path.join(data_dir, "died.png")).convert_alpha()
            death_image = pygame.transform.scale(death_image, (self.width // 2, self.height // 2))
        except pygame.error as e:
            print(f"Error loading death image: {e}")
            death_image = None

        button_width = 200
        button_height = 60
        button_padding = 40

        restart_button_rect = pygame.Rect(
            button_padding,
            self.height - button_height - button_padding,
            button_width,
            button_height
        )

        menu_button_rect = pygame.Rect(
            self.width - button_width - button_padding,
            self.height - button_height - button_padding,
            button_width,
            button_height
        )

        running = True
        while running:
            self.screen.fill(BLACK)

            if death_image:
                death_rect = death_image.get_rect(center=(self.width // 2, self.height // 3))
                self.screen.blit(death_image, death_rect)

            for rect, text, color in [
                (restart_button_rect, "Рестарт", (0, 200, 0)),
                (menu_button_rect, "Меню", (200, 0, 0))
            ]:
                pygame.draw.rect(self.screen, color, rect, border_radius=10)
                text_surf = self.font.render(text, True, WHITE)
                text_rect = text_surf.get_rect(center=rect.center)
                self.screen.blit(text_surf, text_rect)

            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

                if event.type == pygame.MOUSEBUTTONDOWN:
                    if restart_button_rect.collidepoint(event.pos):
                        if self.click_sound:
                            self.click_sound.play()
                        self.killed_enemies = 0
                        self.player_health = self.player_max_health
                        self.saved_hero_pos = None
                        running = False
                        self.show_game_map(self.selected_character)

                    elif menu_button_rect.collidepoint(event.pos):
                        if self.click_sound:
                            self.click_sound.play()
                        running = False
                        self.show_menu_screen()

    def draw_menu_screen(self):
        global exclamation_button_rect
        self.screen.fill(BLACK)
        for star in self.stars:
            pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])

        title_font = pygame.font.SysFont(GAME_FONT, 150)
        title_text = title_font.render("Сквозь Миры", True, (192, 192, 192))
        title_rect = title_text.get_rect(center=(self.width // 2, self.height // 8))
        self.screen.blit(title_text, title_rect)

        menu_font = pygame.font.SysFont(GAME_FONT, 100)
        menu_text = menu_font.render("Меню", True, WHITE)
        menu_rect = menu_text.get_rect(center=(self.width // 2, self.height // 4))
        self.screen.blit(menu_text, menu_rect)

        button_width = self.width // 5
        button_height = 50
        button_x = self.width // 2 - button_width // 2
        button_y_spacing = 20
        button_texts = ["Начать новую игру", "Продолжить игру", "Рейтинг", "Настройки", "Выйти"]
        self.buttons = []
        for i, text in enumerate(button_texts):
            button_y = menu_rect.bottom + 50 + i * (button_height + button_y_spacing)
            button_rect = pygame.Rect(button_x, button_y, button_width, button_height)
            pygame.draw.rect(self.screen, GRAY, button_rect)
            button_font = pygame.font.SysFont(GAME_FONT, 30)
            button_text = button_font.render(text, True, WHITE)
            button_text_rect = button_text.get_rect(center=button_rect.center)
            self.screen.blit(button_text, button_text_rect)
            self.buttons.append(button_rect)

        try:
            exclamation_button_image = pygame.image.load(
                os.path.join(data_dir, "exclamation_button.png")).convert_alpha()
            exclamation_button_rect = exclamation_button_image.get_rect(
                topleft=(20, 20))
            self.screen.blit(exclamation_button_image, exclamation_button_rect)
        except pygame.error as e:
            print(f"Error loading exclamation button image: {e}")

        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1:
                    for i, rect in enumerate(self.buttons):
                        if rect.collidepoint(event.pos):
                            if self.click_sound:
                                self.click_sound.play()
                            if i == 0:
                                self.choose_character()
                            elif i == 1:
                                self.show_game_map(self.selected_character)
                            elif i == 3:
                                self.show_settings_menu()
                            elif i == 4:
                                self.show_exit_menu()
                            elif i == 2:
                                self.show_rating()
                    if exclamation_button_rect.collidepoint(event.pos):
                        self.show_instructions()

    def generate_stars(self, num_stars):
        for _ in range(num_stars):
            x = random.randint(0, self.width)
            y = random.randint(0, self.height)
            size = random.randint(1, 3)
            self.stars.append([x, y, size])

    def show_instructions(self):
        instructions = [
            "Инструкция:",
            "1. Используйте W, A, S, D для перемещения.",
            "2. Нажмите пробел для атаки.",
            "3. Используйте R для перезарядки.",
            "4. Избегайте врагов и собирайте здоровье.",
            "5. Нажмите ESC для выхода в меню."
        ]

        font = pygame.font.SysFont(None, 36)
        padding = 20
        frame_width = 500
        frame_height = 300
        frame_rect = pygame.Rect(self.width // 2 - frame_width // 2, self.height // 2 - frame_height // 2, frame_width,
                                 frame_height)

        pygame.draw.rect(self.screen, GRAY, frame_rect, border_radius=10)

        for i, line in enumerate(instructions):
            text_surface = font.render(line, True, WHITE)
            text_rect = text_surface.get_rect(topleft=(frame_rect.left + padding, frame_rect.top + padding + i * 40))
            self.screen.blit(text_surface, text_rect)

        close_button_rect = pygame.Rect(frame_rect.right - 30, frame_rect.top + 10, 20, 20)
        pygame.draw.rect(self.screen, RED, close_button_rect)
        close_button_text = font.render("X", True, WHITE)
        close_button_text_rect = close_button_text.get_rect(center=close_button_rect.center)
        self.screen.blit(close_button_text, close_button_text_rect)

        pygame.display.flip()

        waiting = True
        while waiting:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if close_button_rect.collidepoint(event.pos):
                        waiting = False
                if event.type == pygame.KEYDOWN:
                    waiting = False

    def draw(self):
        self.screen.fill(BLACK)
        for star in self.stars:
            pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])
        draw_pixel_text(self.screen, "Сквозь Миры", 100, self.width // 2, 100, WHITE, font=GAME_FONT)
        if self.selected_character:
            draw_pixel_text(self.screen,
                            f"Выбран персонаж: {self.selected_character.name}, Имя: {self.player_name}",
                            48, self.width // 2, self.height // 2 + 100, WHITE, font=GAME_FONT)

    def load_images(self):
        self.character_images = []
        for char_data in characters:
            try:
                image = pygame.image.load(os.path.join(data_dir, char_data.image_name)).convert_alpha()
                bright_image = pygame.image.load(os.path.join(data_dir, char_data.bright_image_name)).convert_alpha()
                image = scale_image(image, 0.6)
                bright_image = scale_image(bright_image, 0.6)

                if image and bright_image:
                    self.character_images.append(image)
                    char_data.image = image
                    char_data.bright_image = bright_image
                    char_data.rect = image.get_rect()
                else:
                    print(f"Error loading images for {char_data.name}. Skipping character.")

            except pygame.error as e:
                print(f"Error loading images for {char_data.name}: {e}. Skipping character.")

    def load_sounds(self):
        try:
            self.click_sound = pygame.mixer.Sound(os.path.join(sounds_dir, "button_click.wav"))
            self.click_sound.set_volume(0.2)
            self.sword_sound = pygame.mixer.Sound(os.path.join(sounds_dir, "sword.wav"))
            self.sword_sound.set_volume(0.5)
            print("Button click sound loaded successfully.")
        except pygame.error as e:
            print(f"Error loading sound file: {e}")
            self.click_sound = None
            self.sword_sound = None

    def show_story(self):
        story_text = [
            "В далеком будущем...",
            "Миры соединяются с помощью таинственных порталов.",
            "Они стремятся разрушить все на своем пути.",
            "Города падут, и надежда угаснет, если не встать на защиту.",
            "Но среди хаоса появляются герои — отважные защитники.",
            "Они готовы сразиться с надвигающейся угрозой.",
            "Объединив силы, герои должны закрыть портал и остановить нашествие.",
            "Судьба человечества висит на волоске.",
            "Приготовьтесь к битве за выживание.",
            "Время действовать настало!"
        ]
        font = pygame.font.SysFont(None, 64)
        y_offset = 200
        text_surfaces = [font.render(line, True, YELLOW) for line in story_text]
        y_positions = [y_offset + i * 70 for i in range(len(text_surfaces))]
        scroll_speed = 1
        all_lines_offscreen = False
        skip_story = False
        running = True
        clock = pygame.time.Clock()

        while running and not all_lines_offscreen:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        skip_story = True
                        break
            if skip_story:
                break

            self.screen.fill(BLACK)
            for star in self.stars:
                pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])
            visible_text = []
            for i, text_surface in enumerate(text_surfaces):
                y_positions[i] -= scroll_speed
                if y_positions[i] + text_surface.get_height() > 0:
                    text_rect = text_surface.get_rect(center=(self.width // 2, y_positions[i]))
                    self.screen.blit(text_surface, text_rect)
                    visible_text.append(text_surface)

            all_lines_offscreen = all(
                y_positions[i] + text_surfaces[i].get_height() <= 0 for i in range(len(text_surfaces)))

            pygame.display.flip()
            clock.tick(30)

    def show_menu_screen(self):
        pygame.mouse.set_visible(True)

        menu_running = True
        self.menu_opened_from_shooting_range = False
        self.test_x = 0
        self.test_y = 0
        self.flipped_image = False
        if self.selected_character:
            self.previous_test_x = self.test_x
            self.previous_test_y = self.test_y
            self.previous_flipped_image = self.flipped_image

        while menu_running:
            self.draw_menu_screen()
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                    menu_running = False
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    for i, rect in enumerate(self.buttons):
                        if rect.collidepoint(event.pos):
                            if self.click_sound:
                                self.click_sound.play()
                            if i == 0:
                                self.choose_character()
                            elif i == 1:
                                menu_running = False
                                if self.saved_game_state == "game_map":
                                    self.show_game_map(self.selected_character)
                                elif self.saved_game_state == "shooting_range":
                                    self.show_shooting_range()
                            elif i == 3:
                                self.show_settings_menu()
                            elif i == 4:
                                self.show_exit_menu()
                            elif i == 2:
                                self.show_rating()

    def show_exit_menu(self):
        font_title = pygame.font.SysFont(GAME_FONT, 100)
        font_button = pygame.font.SysFont(GAME_FONT, 72)
        button_width = 300
        button_height = 120
        button_spacing = 80

        button1_rect = pygame.Rect((self.width - button_width) // 2,
                                   (self.height // 2) - button_height - button_spacing // 2, button_width,
                                   button_height)
        button2_rect = pygame.Rect((self.width - button_width) // 2, (self.height // 2) + button_spacing // 2,
                                   button_width, button_height)

        exit_menu = True
        while exit_menu:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    quit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if button1_rect.collidepoint(event.pos):
                        if self.click_sound:
                            self.click_sound.play()
                        pygame.quit()
                        quit()
                    if button2_rect.collidepoint(event.pos):
                        if self.click_sound:
                            self.click_sound.play()
                        exit_menu = False

            self.screen.fill(BLACK)
            for star in self.stars:
                pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])

            title_text = font_title.render("Выйти из игры?", True, WHITE)
            title_rect = title_text.get_rect(center=(self.width // 2, self.height // 4))
            self.screen.blit(title_text, title_rect)

            pygame.draw.rect(self.screen, (80, 80, 200), button1_rect)
            button1_text = font_button.render("Выйти", True, WHITE)
            button1_text_rect = button1_text.get_rect(center=button1_rect.center)
            self.screen.blit(button1_text, button1_text_rect)

            pygame.draw.rect(self.screen, (80, 80, 200), button2_rect)
            button2_text = font_button.render("Остаться", True, WHITE)
            button2_text_rect = button2_text.get_rect(center=button2_rect.center)
            self.screen.blit(button2_text, button2_text_rect)

            pygame.display.flip()

    def choose_character(self):
        selected_character = None
        confirm_button_pressed = False

        while not confirm_button_pressed:
            confirm_button_rect = self.draw_choose_character_screen()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

                if event.type == pygame.MOUSEBUTTONDOWN:
                    if confirm_button_rect.collidepoint(event.pos) and selected_character is not None:
                        confirm_button_pressed = True

                    for i, char in enumerate(characters):
                        if self.character_images[i] and char.rect and char.rect.collidepoint(event.pos):
                            selected_character = char
                            char.highlighted = True
                            for other_char in characters:
                                if other_char != char:
                                    other_char.highlighted = False
                            if selected_character.name == "Немецкий медик":
                                self.ammo = 5
                            elif selected_character.name == "Военный Нигерии":
                                self.ammo = 0
                                self.player_max_health = 12
                                self.player_health = 12
                            else:
                                self.ammo = 10

            if confirm_button_pressed and selected_character:
                self.player_name = input_box(self.screen, "Введите имя персонажа:", self.width, self.height, self.stars)
                self.selected_character = selected_character
                self.show_character_intro(selected_character)
                return selected_character

    def draw_choose_character_screen(self):
        self.screen.fill(BLACK)
        for star in self.stars:
            pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])

        if self.character_images:
            try:
                russian_soldier_index = characters.index(
                    next(char for char in characters if char.name == "Русский военный"))
                russian_soldier_image = self.character_images[russian_soldier_index]
            except (StopIteration, ValueError, IndexError):
                print("Error: 'Русский военный' not found or images not loaded properly.")
                return

            spacing = 25
            total_width = sum(img.get_width() for img in self.character_images) + (len(characters) - 1) * spacing
            x_offset = max(0, (self.width - total_width) // 2)

            for i, char in enumerate(characters):
                if self.character_images[i]:
                    try:
                        russian_soldier_index = characters.index(
                            next(c for c in characters if c.name == "Русский военный"))
                        base_height = self.character_images[russian_soldier_index].get_height()
                    except (StopIteration, ValueError, IndexError):
                        print("Error: 'Русский военный' not found or images not loaded properly.")
                        return

                    target_height = base_height
                    aspect_ratio = self.character_images[i].get_width() / self.character_images[i].get_height()
                    new_width = int(target_height * aspect_ratio)

                    scaled_image = pygame.transform.scale(self.character_images[i], (new_width, target_height))
                    scaled_bright_image = pygame.transform.scale(characters[i].bright_image, (new_width, target_height))

                    x_pos = x_offset + sum(img.get_width() for img in self.character_images[:i]) + i * spacing
                    char.rect = pygame.Rect(x_pos, (self.height - target_height) // 2, new_width, target_height)
                    self.screen.blit(scaled_bright_image if char.highlighted else scaled_image, char.rect)

            button_width = 300
            button_height = 80
            button_x = (self.width - button_width) // 2
            button_y = self.height - 150
            confirm_button_rect = pygame.Rect(button_x, button_y, button_width, button_height)

            pygame.draw.rect(self.screen, (80, 80, 200), confirm_button_rect, border_radius=20)
            font = pygame.font.SysFont(None, 48)
            text = font.render("Подтвердить", True, WHITE)
            text_rect = text.get_rect(center=confirm_button_rect.center)
            self.screen.blit(text, text_rect)

            pygame.display.flip()
            return confirm_button_rect

    def show_character_intro(self, selected_character
