import pygame
import random
import os
import sys
import time


class Character:
    def __init__(self, name, image_name, bright_image_name, speed):
        self.name = name
        self.image_name = image_name
        self.bright_image_name = bright_image_name
        self.speed = speed
        self.image = None
        self.bright_image = None
        self.rect = None
        self.highlighted = False


characters = [
    Character("Немецкий медик", "german_medic.png", "german_medic_bright.png", 5),
    Character("Военный Нигерии", "nigerian_soldier.png", "nigerian_soldier_bright.png", 2),
    Character("Русский военный", "russian_soldier.png", "russian_soldier_bright.png", 3),
]


class Camera:
    def __init__(self, width, height):
        self.dx = 0
        self.dy = 0
        self.width = width
        self.height = height

    def update(self, hero_pos):
        cell_size = 140
        self.dx = self.width // 2 - (hero_pos[0] * cell_size + cell_size // 2)
        self.dy = self.height // 2 - (hero_pos[1] * cell_size + cell_size // 2)


class Hero(pygame.sprite.Sprite):
    def __init__(self, image, pos):
        super().__init__()
        self.image = image
        self.rect = self.image.get_rect(topleft=pos)


def initialize_pygame():
    pygame.init()
    pygame.mixer.init()


def define_constants():
    global FPS, WHITE, BLACK, GRAY, YELLOW, RED, data_dir, sounds_dir, GAME_FONT
    FPS = 60
    WHITE = (255, 255, 255)
    BLACK = (0, 0, 0)
    GRAY = (50, 50, 50)
    YELLOW = (255, 255, 0)
    RED = (255, 0, 0)
    data_dir = os.path.join(os.path.dirname(__file__), "data")
    sounds_dir = os.path.join(os.path.dirname(__file__), "sounds")
    GAME_FONT = "comicsansms"


def draw_pixel_text(surface, text, font_size, x, y, color, font):
    font = pygame.font.SysFont(font, font_size)
    text_surface = font.render(text, True, color)
    text_rect = text_surface.get_rect(center=(x, y))
    blurred_surface = pygame.transform.scale(text_surface,
                                             (text_surface.get_width() * 2, text_surface.get_height() * 2))
    blurred_surface = pygame.transform.scale(blurred_surface, text_surface.get_size())
    surface.blit(blurred_surface, text_rect)


def input_box(screen, message, width, height, stars):
    font = pygame.font.Font(None, 36)
    input_rect = pygame.Rect((width - 600) // 2, (height - 50) // 2, 600, 50)
    color_active = pygame.Color('lightskyblue3')
    color_passive = pygame.Color('chartreuse4')
    active = False
    text = ''
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                quit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                active = input_rect.collidepoint(event.pos)
            if event.type == pygame.KEYDOWN:
                if active:
                    if event.key == pygame.K_RETURN:
                        running = False
                    elif event.key == pygame.K_BACKSPACE:
                        text = text[:-1]
                    else:
                        text += event.unicode

        screen.fill(BLACK)
        for star in stars:
            pygame.draw.circle(screen, WHITE, (star[0], star[1]), star[2])
        draw_pixel_text(screen, message, 48, width // 2, input_rect.top - 50, WHITE, font=GAME_FONT)
        color = color_active if active else color_passive
        pygame.draw.rect(screen, color, input_rect, 2)
        text_surface = font.render(text, True, color)
        screen.blit(text_surface, (input_rect.x + 5, input_rect.y + 5))
        pygame.display.flip()
    return text


def scale_image(image, scale_factor):
    new_width = int(image.get_width() * scale_factor)
    new_height = int(image.get_height() * scale_factor)
    return pygame.transform.scale(image, (new_width, new_height))


def create_cursor(cursor_image):
    try:
        if cursor_image is None:
            print("Warning: Cursor image not loaded correctly.")
            return None, None
        cursor_rect = cursor_image.get_rect()
        return cursor_image, cursor_rect
    except AttributeError as e:
        print(f"Error getting cursor rect: {e}")
        return None, None
    except Exception as e:
        print(f"An unexpected error occurred in create_cursor: {e}")
        return None, None


class MainScreen:
    def __init__(self, width, height):
        self.killed_enemies = 0
        self.total_enemies = 1
        self.volume_slider_rect = None
        self.settings_buttons = None
        self.aim_cursor_rect = None
        self.aim_cursor = None
        self.shot_sound = None
        self.reload_sound = None
        self.walk_sound = None
        self.click_sound = None
        self.character_images = None
        self.width = width
        self.height = height
        self.screen = pygame.display.set_mode((self.width, self.height))
        self.stars = []
        self.generate_stars(200)
        self.load_images()
        self.load_sounds()
        self.player_name = ""
        self.selected_character = None
        self.font = pygame.font.SysFont(None, 64)
        self.buttons = []
        self.volume = 0.5
        self.menu_opened_from_shooting_range = False
        self.previous_test_x = 0
        self.previous_test_y = 0
        self.previous_flipped_image = False
        self.test_x = 0
        self.test_y = 0
        self.flipped_image = False
        self.ammo = 0
        self.camera = Camera(self.width, self.height)
        self.saved_hero_pos = None
        self.saved_game_state = None
        self.game_results = []
        self.load_game_results()
        self.player_health = 10
        self.player_max_health = 10

    def run(self):
        if self.walk_sound and self.walk_sound.get_num_channels() > 0:
            self.walk_sound.stop()

        draw_pixel_text(self.screen, "Сквозь Миры", 150, self.width // 2, self.height // 3, YELLOW, font=GAME_FONT)
        pygame.display.flip()
        time.sleep(3)
        self.screen.fill(BLACK)
        self.show_story()
        self.show_menu_screen()
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        if self.selected_character:
                            self.show_menu_screen()
                        else:
                            self.show_menu_screen()
                    elif event.key == pygame.K_SPACE and self.selected_character is None:
                        self.choose_character()

            if self.selected_character:
                self.show_shooting_range()
            self.draw()
            pygame.display.flip()

        pygame.quit()
        sys.exit()

    def show_win_screen(self):
        pygame.mouse.set_visible(True)
        try:
            win_image = pygame.image.load(os.path.join(data_dir, "win.png")).convert_alpha()
            win_image = pygame.transform.scale(win_image, (self.width // 2, self.height // 2))
        except pygame.error:
            win_image = None

        button_width = 200
        button_height = 60
        button_padding = 40

        menu_button_rect = pygame.Rect(
            (self.width - button_width) // 2,
            self.height - button_height - button_padding,
            button_width,
            button_height
        )

        rating_button_rect = pygame.Rect(
            (self.width - button_width) // 2,
            self.height - button_height * 2 - button_padding * 2,
            button_width,
            button_height
        )

        running = True
        while running:
            self.screen.fill(BLACK)
            for star in self.stars:
                pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])

            if win_image:
                win_rect = win_image.get_rect(center=(self.width // 2, self.height // 3))
                self.screen.blit(win_image, win_rect)

            for rect, text, color in [
                (menu_button_rect, "Меню", (0, 200, 0)),
                (rating_button_rect, "Рейтинг", (200, 0, 0))
            ]:
                pygame.draw.rect(self.screen, color, rect, border_radius=10)
                text_surf = self.font.render(text, True, WHITE)
                text_rect = text_surf.get_rect(center=rect.center)
                self.screen.blit(text_surf, text_rect)

            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if menu_button_rect.collidepoint(event.pos):
                        if self.click_sound:
                            self.click_sound.play()
                        running = False
                        self.show_menu_screen()
                    elif rating_button_rect.collidepoint(event.pos):
                        if self.click_sound:
                            self.click_sound.play()
                        self.show_rating()

            pos = pygame.mouse.get_pos()
            for event in pygame.event.get():
                if event.type == pygame.MOUSEMOTION:
                    pygame.draw.circle(self.screen, WHITE, pos, 3)

    def save_game_result(self, kills, time_seconds):
        result = f"{self.player_name}\t{kills}\t{time_seconds}\t{time.time()}\n"

        self.game_results.append({
            "player": self.player_name,
            "kills": kills,
            "time": time_seconds,
            "timestamp": time.time()
        })

        self.game_results.sort(key=lambda x: (x['time'], -x['kills']))

        if len(self.game_results) > 10:
            self.game_results = self.game_results[:10]

        try:
            with open("results.txt", "w") as f:
                for res in self.game_results:
                    f.write(f"{res['player']}\t{res['kills']}\t{res['time']}\t{res['timestamp']}\n")
        except Exception as e:
            print(f"Error saving results: {e}")

    def load_game_results(self):
        self.game_results = []
        try:
            with open("results.txt", "r") as f:
                for line in f.readlines():
                    try:
                        parts = line.strip().split('\t')
                        if len(parts) == 4:
                            self.game_results.append({
                                "player": parts[0],
                                "kills": int(parts[1]),
                                "time": int(parts[2]),
                                "timestamp": float(parts[3])
                            })
                    except (ValueError, IndexError) as e:
                        print(f"Error parsing line: {line.strip()} - {e}")
        except FileNotFoundError:
            print("Results file not found, starting fresh")
        except Exception as e:
            print(f"Error loading results: {e}")

    def show_rating(self):
        rating_font = pygame.font.SysFont(GAME_FONT, 48)
        small_font = pygame.font.SysFont(GAME_FONT, 28)

        rating_surface = pygame.Surface((600, 500), pygame.SRCALPHA)
        rating_surface.fill((30, 30, 30, 200))

        title = rating_font.render("Топ игроков", True, WHITE)
        rating_surface.blit(title, (20, 20))

        place_colors = {
            0: (255, 215, 0),
            1: (192, 192, 192),
            2: (205, 127, 50)
        }

        y = 80
        for i, result in enumerate(self.game_results[:10]):
            color = place_colors.get(i, (150, 150, 150))
            time_str = f"{result['time'] // 60:02}мин {result['time'] % 60:02}сек"
            text = f"{i + 1}. {result['player'][:15]:<15} Уб: {result['kills']:2} Вр: {time_str}"
            text_surf = small_font.render(text, True, color)
            rating_surface.blit(text_surf, (20, y))
            y += 50

        rating_rect = rating_surface.get_rect(center=(self.width // 2, self.height // 2))

        running = True
        while running:
            self.screen.fill(BLACK)
            for star in self.stars:
                pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])

            self.screen.blit(rating_surface, rating_rect)

            pygame.display.flip()

            for event in pygame.event.get():
                if event.type in (pygame.QUIT, pygame.MOUSEBUTTONDOWN, pygame.KEYDOWN):
                    running = False

    def show_message(self, message):
        font = pygame.font.SysFont(None, 48)
        padding = 20
        frame_width = 600
        frame_height = 200
        frame_rect = pygame.Rect(self.width // 2 - frame_width // 2, self.height // 2 - frame_height // 2, frame_width,
                                 frame_height)

        pygame.draw.rect(self.screen, GRAY, frame_rect, border_radius=10)

        text_surface = font.render(message, True, WHITE)
        text_rect = text_surface.get_rect(center=(frame_rect.centerx, frame_rect.centery - 20))
        self.screen.blit(text_surface, text_rect)

        close_button_rect = pygame.Rect(frame_rect.right - 40, frame_rect.top + 10, 30, 30)
        pygame.draw.rect(self.screen, RED, close_button_rect, border_radius=15)
        close_button_text = font.render("X", True, WHITE)
        close_button_text_rect = close_button_text.get_rect(center=close_button_rect.center)
        self.screen.blit(close_button_text, close_button_text_rect)

        pygame.display.flip()

        waiting = True
        while waiting:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if close_button_rect.collidepoint(event.pos):
                        waiting = False

    def show_death_screen(self):
        try:
            death_image = pygame.image.load(os.path.join(data_dir, "died.png")).convert_alpha()
            death_image = pygame.transform.scale(death_image, (self.width // 2, self.height // 2))
        except pygame.error as e:
            print(f"Error loading death image: {e}")
            death_image = None

        button_width = 200
        button_height = 60
        button_padding = 40

        restart_button_rect = pygame.Rect(
            button_padding,
            self.height - button_height - button_padding,
            button_width,
            button_height
        )

        menu_button_rect = pygame.Rect(
            self.width - button_width - button_padding,
            self.height - button_height - button_padding,
            button_width,
            button_height
        )

        running = True
        while running:
            self.screen.fill(BLACK)

            if death_image:
                death_rect = death_image.get_rect(center=(self.width // 2, self.height // 3))
                self.screen.blit(death_image, death_rect)

            for rect, text, color in [
                (restart_button_rect, "Рестарт", (0, 200, 0)),
                (menu_button_rect, "Меню", (200, 0, 0))
            ]:
                pygame.draw.rect(self.screen, color, rect, border_radius=10)
                text_surf = self.font.render(text, True, WHITE)
                text_rect = text_surf.get_rect(center=rect.center)
                self.screen.blit(text_surf, text_rect)

            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

                if event.type == pygame.MOUSEBUTTONDOWN:
                    if restart_button_rect.collidepoint(event.pos):
                        if self.click_sound:
                            self.click_sound.play()
                        self.killed_enemies = 0
                        self.player_health = self.player_max_health
                        self.saved_hero_pos = None
                        running = False
                        self.show_game_map(self.selected_character)

                    elif menu_button_rect.collidepoint(event.pos):
                        if self.click_sound:
                            self.click_sound.play()
                        running = False
                        self.show_menu_screen()

    def draw_menu_screen(self):
        global exclamation_button_rect
        self.screen.fill(BLACK)
        for star in self.stars:
            pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])

        title_font = pygame.font.SysFont(GAME_FONT, 150)
        title_text = title_font.render("Сквозь Миры", True, (192, 192, 192))
        title_rect = title_text.get_rect(center=(self.width // 2, self.height // 8))
        self.screen.blit(title_text, title_rect)

        menu_font = pygame.font.SysFont(GAME_FONT, 100)
        menu_text = menu_font.render("Меню", True, WHITE)
        menu_rect = menu_text.get_rect(center=(self.width // 2, self.height // 4))
        self.screen.blit(menu_text, menu_rect)

        button_width = self.width // 5
        button_height = 50
        button_x = self.width // 2 - button_width // 2
        button_y_spacing = 20
        button_texts = ["Начать новую игру", "Продолжить игру", "Рейтинг", "Настройки", "Выйти"]
        self.buttons = []
        for i, text in enumerate(button_texts):
            button_y = menu_rect.bottom + 50 + i * (button_height + button_y_spacing)
            button_rect = pygame.Rect(button_x, button_y, button_width, button_height)
            pygame.draw.rect(self.screen, GRAY, button_rect)
            button_font = pygame.font.SysFont(GAME_FONT, 30)
            button_text = button_font.render(text, True, WHITE)
            button_text_rect = button_text.get_rect(center=button_rect.center)
            self.screen.blit(button_text, button_text_rect)
            self.buttons.append(button_rect)

        try:
            exclamation_button_image = pygame.image.load(
                os.path.join(data_dir, "exclamation_button.png")).convert_alpha()
            exclamation_button_rect = exclamation_button_image.get_rect(
                topleft=(20, 20))
            self.screen.blit(exclamation_button_image, exclamation_button_rect)
        except pygame.error as e:
            print(f"Error loading exclamation button image: {e}")

        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1:
                    for i, rect in enumerate(self.buttons):
                        if rect.collidepoint(event.pos):
                            if self.click_sound:
                                self.click_sound.play()
                            if i == 0:
                                self.choose_character()
                            elif i == 1:
                                self.show_game_map(self.selected_character)
                            elif i == 3:
                                self.show_settings_menu()
                            elif i == 4:
                                self.show_exit_menu()
                            elif i == 2:
                                self.show_rating()
                    if exclamation_button_rect.collidepoint(event.pos):
                        self.show_instructions()

    def generate_stars(self, num_stars):
        for _ in range(num_stars):
            x = random.randint(0, self.width)
            y = random.randint(0, self.height)
            size = random.randint(1, 3)
            self.stars.append([x, y, size])

    def show_instructions(self):
        instructions = [
            "Инструкция:",
            "1. Используйте W, A, S, D для перемещения.",
            "2. Нажмите пробел для атаки.",
            "3. Используйте R для перезарядки.",
            "4. Избегайте врагов и собирайте здоровье.",
            "5. Нажмите ESC для выхода в меню."
        ]

        font = pygame.font.SysFont(None, 36)
        padding = 20
        frame_width = 500
        frame_height = 300
        frame_rect = pygame.Rect(self.width // 2 - frame_width // 2, self.height // 2 - frame_height // 2, frame_width,
                                 frame_height)

        pygame.draw.rect(self.screen, GRAY, frame_rect, border_radius=10)

        for i, line in enumerate(instructions):
            text_surface = font.render(line, True, WHITE)
            text_rect = text_surface.get_rect(topleft=(frame_rect.left + padding, frame_rect.top + padding + i * 40))
            self.screen.blit(text_surface, text_rect)

        close_button_rect = pygame.Rect(frame_rect.right - 30, frame_rect.top + 10, 20, 20)
        pygame.draw.rect(self.screen, RED, close_button_rect)
        close_button_text = font.render("X", True, WHITE)
        close_button_text_rect = close_button_text.get_rect(center=close_button_rect.center)
        self.screen.blit(close_button_text, close_button_text_rect)

        pygame.display.flip()

        waiting = True
        while waiting:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if close_button_rect.collidepoint(event.pos):
                        waiting = False
                if event.type == pygame.KEYDOWN:
                    waiting = False

    def draw(self):
        self.screen.fill(BLACK)
        for star in self.stars:
            pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])
        draw_pixel_text(self.screen, "Сквозь Миры", 100, self.width // 2, 100, WHITE, font=GAME_FONT)
        if self.selected_character:
            draw_pixel_text(self.screen,
                            f"Выбран персонаж: {self.selected_character.name}, Имя: {self.player_name}",
                            48, self.width // 2, self.height // 2 + 100, WHITE, font=GAME_FONT)

    def load_images(self):
        self.character_images = []
        for char_data in characters:
            try:
                image = pygame.image.load(os.path.join(data_dir, char_data.image_name)).convert_alpha()
                bright_image = pygame.image.load(os.path.join(data_dir, char_data.bright_image_name)).convert_alpha()
                image = scale_image(image, 0.6)
                bright_image = scale_image(bright_image, 0.6)

                if image and bright_image:
                    self.character_images.append(image)
                    char_data.image = image
                    char_data.bright_image = bright_image
                    char_data.rect = image.get_rect()
                else:
                    print(f"Error loading images for {char_data.name}. Skipping character.")

            except pygame.error as e:
                print(f"Error loading images for {char_data.name}: {e}. Skipping character.")

    def load_sounds(self):
        try:
            self.click_sound = pygame.mixer.Sound(os.path.join(sounds_dir, "button_click.wav"))
            self.click_sound.set_volume(0.2)
            self.sword_sound = pygame.mixer.Sound(os.path.join(sounds_dir, "sword.wav"))
            self.sword_sound.set_volume(0.5)
            print("Button click sound loaded successfully.")
        except pygame.error as e:
            print(f"Error loading sound file: {e}")
            self.click_sound = None
            self.sword_sound = None

    def show_story(self):
        story_text = [
            "В далеком будущем...",
            "Миры соединяются с помощью таинственных порталов.",
            "Они стремятся разрушить все на своем пути.",
            "Города падут, и надежда угаснет, если не встать на защиту.",
            "Но среди хаоса появляются герои — отважные защитники.",
            "Они готовы сразиться с надвигающейся угрозой.",
            "Объединив силы, герои должны закрыть портал и остановить нашествие.",
            "Судьба человечества висит на волоске.",
            "Приготовьтесь к битве за выживание.",
            "Время действовать настало!"
        ]
        font = pygame.font.SysFont(None, 64)
        y_offset = 200
        text_surfaces = [font.render(line, True, YELLOW) for line in story_text]
        y_positions = [y_offset + i * 70 for i in range(len(text_surfaces))]
        scroll_speed = 1
        all_lines_offscreen = False
        skip_story = False
        running = True
        clock = pygame.time.Clock()

        while running and not all_lines_offscreen:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        skip_story = True
                        break
            if skip_story:
                break

            self.screen.fill(BLACK)
            for star in self.stars:
                pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])
            visible_text = []
            for i, text_surface in enumerate(text_surfaces):
                y_positions[i] -= scroll_speed
                if y_positions[i] + text_surface.get_height() > 0:
                    text_rect = text_surface.get_rect(center=(self.width // 2, y_positions[i]))
                    self.screen.blit(text_surface, text_rect)
                    visible_text.append(text_surface)

            all_lines_offscreen = all(
                y_positions[i] + text_surfaces[i].get_height() <= 0 for i in range(len(text_surfaces)))

            pygame.display.flip()
            clock.tick(30)

    def show_menu_screen(self):
        pygame.mouse.set_visible(True)

        menu_running = True
        self.menu_opened_from_shooting_range = False
        self.test_x = 0
        self.test_y = 0
        self.flipped_image = False
        if self.selected_character:
            self.previous_test_x = self.test_x
            self.previous_test_y = self.test_y
            self.previous_flipped_image = self.flipped_image

        while menu_running:
            self.draw_menu_screen()
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                    menu_running = False
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    for i, rect in enumerate(self.buttons):
                        if rect.collidepoint(event.pos):
                            if self.click_sound:
                                self.click_sound.play()
                            if i == 0:
                                self.choose_character()
                            elif i == 1:
                                menu_running = False
                                if self.saved_game_state == "game_map":
                                    self.show_game_map(self.selected_character)
                                elif self.saved_game_state == "shooting_range":
                                    self.show_shooting_range()
                            elif i == 3:
                                self.show_settings_menu()
                            elif i == 4:
                                self.show_exit_menu()
                            elif i == 2:
                                self.show_rating()

    def show_exit_menu(self):
        font_title = pygame.font.SysFont(GAME_FONT, 100)
        font_button = pygame.font.SysFont(GAME_FONT, 72)
        button_width = 300
        button_height = 120
        button_spacing = 80

        button1_rect = pygame.Rect((self.width - button_width) // 2,
                                   (self.height // 2) - button_height - button_spacing // 2, button_width,
                                   button_height)
        button2_rect = pygame.Rect((self.width - button_width) // 2, (self.height // 2) + button_spacing // 2,
                                   button_width, button_height)

        exit_menu = True
        while exit_menu:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    quit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if button1_rect.collidepoint(event.pos):
                        if self.click_sound:
                            self.click_sound.play()
                        pygame.quit()
                        quit()
                    if button2_rect.collidepoint(event.pos):
                        if self.click_sound:
                            self.click_sound.play()
                        exit_menu = False

            self.screen.fill(BLACK)
            for star in self.stars:
                pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])

            title_text = font_title.render("Выйти из игры?", True, WHITE)
            title_rect = title_text.get_rect(center=(self.width // 2, self.height // 4))
            self.screen.blit(title_text, title_rect)

            pygame.draw.rect(self.screen, (80, 80, 200), button1_rect)
            button1_text = font_button.render("Выйти", True, WHITE)
            button1_text_rect = button1_text.get_rect(center=button1_rect.center)
            self.screen.blit(button1_text, button1_text_rect)

            pygame.draw.rect(self.screen, (80, 80, 200), button2_rect)
            button2_text = font_button.render("Остаться", True, WHITE)
            button2_text_rect = button2_text.get_rect(center=button2_rect.center)
            self.screen.blit(button2_text, button2_text_rect)

            pygame.display.flip()

    def choose_character(self):
        selected_character = None
        confirm_button_pressed = False

        while not confirm_button_pressed:
            confirm_button_rect = self.draw_choose_character_screen()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

                if event.type == pygame.MOUSEBUTTONDOWN:
                    if confirm_button_rect.collidepoint(event.pos) and selected_character is not None:
                        confirm_button_pressed = True

                    for i, char in enumerate(characters):
                        if self.character_images[i] and char.rect and char.rect.collidepoint(event.pos):
                            selected_character = char
                            char.highlighted = True
                            for other_char in characters:
                                if other_char != char:
                                    other_char.highlighted = False
                            if selected_character.name == "Немецкий медик":
                                self.ammo = 5
                            elif selected_character.name == "Военный Нигерии":
                                self.ammo = 0
                                self.player_max_health = 12
                                self.player_health = 12
                            else:
                                self.ammo = 10

            if confirm_button_pressed and selected_character:
                self.player_name = input_box(self.screen, "Введите имя персонажа:", self.width, self.height, self.stars)
                self.selected_character = selected_character
                self.show_character_intro(selected_character)
                return selected_character

    def draw_choose_character_screen(self):
        self.screen.fill(BLACK)
        for star in self.stars:
            pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])

        if self.character_images:
            try:
                russian_soldier_index = characters.index(
                    next(char for char in characters if char.name == "Русский военный"))
                russian_soldier_image = self.character_images[russian_soldier_index]
            except (StopIteration, ValueError, IndexError):
                print("Error: 'Русский военный' not found or images not loaded properly.")
                return

            spacing = 25
            total_width = sum(img.get_width() for img in self.character_images) + (len(characters) - 1) * spacing
            x_offset = max(0, (self.width - total_width) // 2)

            for i, char in enumerate(characters):
                if self.character_images[i]:
                    try:
                        russian_soldier_index = characters.index(
                            next(c for c in characters if c.name == "Русский военный"))
                        base_height = self.character_images[russian_soldier_index].get_height()
                    except (StopIteration, ValueError, IndexError):
                        print("Error: 'Русский военный' not found or images not loaded properly.")
                        return

                    target_height = base_height
                    aspect_ratio = self.character_images[i].get_width() / self.character_images[i].get_height()
                    new_width = int(target_height * aspect_ratio)

                    scaled_image = pygame.transform.scale(self.character_images[i], (new_width, target_height))
                    scaled_bright_image = pygame.transform.scale(characters[i].bright_image, (new_width, target_height))

                    x_pos = x_offset + sum(img.get_width() for img in self.character_images[:i]) + i * spacing
                    char.rect = pygame.Rect(x_pos, (self.height - target_height) // 2, new_width, target_height)
                    self.screen.blit(scaled_bright_image if char.highlighted else scaled_image, char.rect)

            button_width = 300
            button_height = 80
            button_x = (self.width - button_width) // 2
            button_y = self.height - 150
            confirm_button_rect = pygame.Rect(button_x, button_y, button_width, button_height)

            pygame.draw.rect(self.screen, (80, 80, 200), confirm_button_rect, border_radius=20)
            font = pygame.font.SysFont(None, 48)
            text = font.render("Подтвердить", True, WHITE)
            text_rect = text.get_rect(center=confirm_button_rect.center)
            self.screen.blit(text, text_rect)

            pygame.display.flip()
            return confirm_button_rect

    def show_character_intro(self, selected_character):
        intro_texts = {
            "Немецкий медик": [
                "Вы — опытный немецкий военный медик, оказавшийся втянутым в нечто большее, чем мог представить.",
                f"Вас зовут {self.player_name}, и ваш профессионализм и хладнокровие – ваши главные козыри в этом "
                f"безумии.",
                "Вы прибыли на военную базу в России…"
            ],
            "Военный Нигерии": [
                "Вы — опытный солдат из Нигерии, привыкший к жаре и опасностям своей родины.",
                f"Вас зовут {self.player_name}, но даже ваша выучка не приготовила вас к суровой реальности этого места",
                "Российская военная база стала вашей новой реальностью…"
            ],
            "Русский военный": [
                "Вы — опытный русский военный, привыкший к суровым условиям.",
                f"Вас зовут {self.player_name}, но даже вам предстоит столкнуться с угрозой, превосходящей все ваши ожидания.",
                "Вы находитесь на секретной военной базе в России…"
            ],
        }

        try:
            intro_background = pygame.image.load(os.path.join(data_dir, "intro_background.png")).convert()
            intro_background = pygame.transform.scale(intro_background, (self.width, self.height))
        except pygame.error as e:
            print(f"Error loading intro background: {e}")
            intro_background = None

        font = pygame.font.SysFont(None, 48)
        DARK_GRAY = (50, 50, 50)
        y_offset = 100
        text_surfaces = [font.render(line, True, DARK_GRAY) for line in intro_texts.get(selected_character.name, [])]
        y_positions = [y_offset + i * 70 for i in range(len(text_surfaces))]
        clock = pygame.time.Clock()

        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.KEYDOWN:
                    running = False

            if intro_background:
                self.screen.blit(intro_background, (0, 0))
            else:
                self.screen.fill(BLACK)

            for i, text_surface in enumerate(text_surfaces):
                text_rect = text_surface.get_rect(center=(self.width // 2, y_positions[i]))
                self.screen.blit(text_surface, text_rect)

            pygame.display.flip()
            clock.tick(30)

        self.screen.fill(BLACK)
        self.show_shooting_range()

    def show_shooting_range(self):
        pygame.mouse.set_visible(True)
        self.saved_game_state = "shooting_range"
        try:
            shooting_range_image = pygame.image.load(os.path.join(data_dir, "poligon.png")).convert()
            shooting_range_image = pygame.transform.scale(shooting_range_image, (self.width, self.height))
            target_image = pygame.image.load(os.path.join(data_dir, "target.png")).convert_alpha()
            target_image = pygame.transform.scale(target_image,
                                                  (target_image.get_width() // 2, target_image.get_height() // 2))
            patron_image = pygame.image.load(os.path.join(data_dir, "patron.png")).convert_alpha()
            patron_image = pygame.transform.scale(patron_image,
                                                  (patron_image.get_width() // 2, patron_image.get_height() // 2))
            aim_cursor_image = pygame.image.load(os.path.join(data_dir, "aim.png")).convert_alpha()
            aim_cursor_image = pygame.transform.scale(aim_cursor_image, (
                aim_cursor_image.get_width() // 2, aim_cursor_image.get_height() // 2))

            self.walk_sound = pygame.mixer.Sound(os.path.join(sounds_dir, "dirt_run.wav"))
            self.walk_sound.set_volume(self.volume)
            self.reload_sound = pygame.mixer.Sound(os.path.join(sounds_dir, "reload.wav"))
            self.reload_sound.set_volume(self.volume)
            self.shot_sound = pygame.mixer.Sound(os.path.join(sounds_dir, "shot.wav"))
            self.shot_sound.set_volume(0.1)
            self.sword_sound = pygame.mixer.Sound(os.path.join(sounds_dir, "sword.wav"))
            self.sword_sound.set_volume(0.5)

            character_image_name = {
                "Немецкий медик": "medic_common.png",
                "Военный Нигерии": "niger_common.png",
                "Русский военный": "test.png"
            }.get(self.selected_character.name)

            if character_image_name is None:
                raise ValueError(f"Image not found for character: {self.selected_character.name}")

            test_image = pygame.image.load(os.path.join(data_dir, character_image_name)).convert_alpha()
            test_image = pygame.transform.scale(test_image, (test_image.get_width() // 2, test_image.get_height() // 2))

            test_y = self.height - test_image.get_height() - 28

            self.aim_cursor, self.aim_cursor_rect = create_cursor(aim_cursor_image)
            if self.aim_cursor is None:
                pygame.mouse.set_visible(True)

        except (pygame.error, ValueError, FileNotFoundError) as e:
            print(f"Error loading resources: {e}")
            return

        test_x = self.test_x
        test_speed = 3
        flipped_image = self.flipped_image
        keys_pressed = {pygame.K_a: False, pygame.K_d: False}
        walk_sound_playing = False
        target_x = self.width - target_image.get_width() - 50
        target_y = self.height - target_image.get_height() - 30
        ammo = self.ammo
        reloading = False
        reload_start_time = 0
        shooting = False
        shot_start_time = 0
        melee_attacking = False
        melee_attack_start_time = 0
        bullet_data = []

        running = True
        start_time = pygame.time.get_ticks()
        while running:
            current_time = pygame.time.get_ticks()
            mouse_x, mouse_y = pygame.mouse.get_pos()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        if self.selected_character:
                            self.show_menu_screen()
                    elif event.key == pygame.K_d:
                        keys_pressed[pygame.K_d] = True
                    elif event.key == pygame.K_a:
                        keys_pressed[pygame.K_a] = True
                    elif event.key == pygame.K_r and not reloading and ammo < 10 and self.selected_character.name != "Военный Нигерии":
                        reloading = True
                        reload_start_time = current_time
                        if self.reload_sound:
                            self.reload_sound.play()
                elif event.type == pygame.KEYUP:
                    if event.key == pygame.K_d:
                        keys_pressed[pygame.K_d] = False
                    elif event.key == pygame.K_a:
                        keys_pressed[pygame.K_a] = False
                elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    if self.selected_character.name == "Военный Нигерии":
                        melee_attacking = True
                        melee_attack_start_time = current_time
                        if self.sword_sound:
                            self.sword_sound.play()
                    elif not reloading and ammo > 0:
                        ammo -= 1
                        shooting = True
                        shot_start_time = current_time
                        if self.shot_sound:
                            self.shot_sound.play()
                        bullet_data.append((mouse_x, mouse_y, current_time))

            if reloading and self.selected_character.name != "Военный Нигерии":
                if current_time - reload_start_time >= 2000:
                    ammo = 5 if self.selected_character.name == "Немецкий медик" else 10
                    reloading = False

            if keys_pressed[pygame.K_d] or keys_pressed[pygame.K_a]:
                if not walk_sound_playing and self.walk_sound:
                    self.walk_sound.play(-1)
                walk_sound_playing = True
            else:
                if walk_sound_playing and self.walk_sound:
                    self.walk_sound.stop()
                walk_sound_playing = False

            if keys_pressed[pygame.K_d]:
                test_x += test_speed
                flipped_image = False
            elif keys_pressed[pygame.K_a]:
                test_x -= test_speed
                flipped_image = True

            test_x = max(0, min(test_x, self.width - test_image.get_width()))

            bullet_data = [(x, y, spawn_time) for (x, y, spawn_time) in bullet_data if
                           current_time - spawn_time <= 3000]

            self.screen.fill(BLACK)
            if shooting_range_image:
                self.screen.blit(shooting_range_image, (0, 0))

            displayed_image = pygame.transform.flip(test_image, flipped_image, False)
            self.screen.blit(displayed_image, (test_x, test_y))

            if target_image:
                self.screen.blit(target_image, (target_x, target_y))

            if self.selected_character.name != "Военный Нигерии":
                if patron_image:
                    patron_x = test_x + test_image.get_width() // 2 - patron_image.get_width() // 2 - 32
                    patron_y = test_y - patron_image.get_height() + 55
                    self.screen.blit(patron_image, (patron_x, patron_y))
                    font = pygame.font.SysFont(None, 36)
                    ammo_text = font.render(str(ammo), True, WHITE)
                    text_rect = ammo_text.get_rect(
                        center=(
                            patron_x + patron_image.get_width() // 2, patron_y + patron_image.get_height() // 2 - 10))
                    self.screen.blit(ammo_text, text_rect)

                for bullet in bullet_data:
                    pygame.draw.circle(self.screen, YELLOW, (bullet[0], bullet[1]), 5)

            target_rect = target_image.get_rect(topleft=(target_x, target_y))
            if target_rect.collidepoint(mouse_x, mouse_y):
                pygame.mouse.set_visible(False)
                if self.aim_cursor and self.aim_cursor_rect:
                    self.screen.blit(self.aim_cursor, (
                        mouse_x - self.aim_cursor_rect.width // 2, mouse_y - self.aim_cursor_rect.height // 2))
            else:
                pygame.mouse.set_visible(True)

            pygame.display.flip()
            elapsed_time = current_time - start_time
            if elapsed_time >= 5000:
                self.show_manga()
                running = False

        pygame.mouse.set_visible(True)
        self.test_x = test_x
        self.flipped_image = flipped_image

        for event in pygame.event.get():
            if event.type == pygame.MOUSEMOTION:
                pygame.mouse.set_visible(True)

    def show_manga(self):
        if self.walk_sound and self.walk_sound.get_num_channels() > 0:
            self.walk_sound.stop()

        manga_images = ["manga_radio.png", "manga_portal.png", "manga_car.png", "manga_start.png"]
        current_image_index = 0
        running = True

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
                    current_image_index += 1
                    if current_image_index >= len(manga_images):
                        current_image_index = 0
                        running = False
                if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                    running = False

            try:
                image_path = os.path.join(data_dir, "manga", manga_images[current_image_index])
                image = pygame.image.load(image_path).convert_alpha()
                image = pygame.transform.scale(image, (self.width, self.height))
                self.screen.blit(image, (0, 0))
                pygame.display.flip()
            except pygame.error as e:
                print(f"Error loading manga image: {e}")
                running = False

        self.show_game_map(self.selected_character)

    def show_settings_menu(self):
        running = True
        self.dragging_slider = False

        while running:
            self.screen.fill(BLACK)
            for star in self.stars:
                pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])
            title_font = pygame.font.SysFont(GAME_FONT, 100)
            title_text = title_font.render("Настройки", True, RED)
            title_rect = title_text.get_rect(center=(self.width // 2, self.height // 4))
            self.screen.blit(title_text, title_rect)

            button_width = self.width // 5
            button_height = 60
            button_x = self.width // 2 - button_width // 2
            button_y_spacing = 30

            button_texts = ["Назад", "Применить"]
            self.settings_buttons = []

            for i, text in enumerate(button_texts):
                button_y = title_rect.bottom + 50 + i * (button_height + button_y_spacing)
                button_rect = pygame.Rect(button_x, button_y, button_width, button_height)
                pygame.draw.rect(self.screen, GRAY, button_rect)
                button_font = pygame.font.SysFont(GAME_FONT, 30)
                button_text = button_font.render(text, True, WHITE)
                button_text_rect = button_text.get_rect(center=button_rect.center)
                self.screen.blit(button_text, button_text_rect)
                self.settings_buttons.append(button_rect)

            slider_width = 300
            slider_height = 40
            slider_x = self.width // 2 - slider_width // 2
            slider_y = title_rect.bottom + 50 + 2 * (button_height + button_y_spacing) + 30

            self.volume_slider_rect = pygame.Rect(slider_x, slider_y, slider_width, slider_height)
            pygame.draw.rect(self.screen, GRAY, self.volume_slider_rect, border_radius=10)

            thumb_x = slider_x + int(self.volume * slider_width) - slider_height // 2
            thumb_rect = pygame.Rect(thumb_x, slider_y, slider_height, slider_height)
            pygame.draw.rect(self.screen, RED, thumb_rect, border_radius=10)

            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    for i, rect in enumerate(self.settings_buttons):
                        if rect.collidepoint(event.pos):
                            if self.click_sound:
                                self.click_sound.play()
                            if i == 0:
                                running = False
                            elif i == 1:
                                pass
                    if self.volume_slider_rect.collidepoint(event.pos):
                        self.dragging_slider = True
                        self.adjust_volume(event)
                elif event.type == pygame.MOUSEBUTTONUP:
                    self.dragging_slider = False
                elif event.type == pygame.MOUSEMOTION:
                    if self.dragging_slider:
                        self.adjust_volume(event)

                thumb_x = slider_x + int(self.volume * slider_width) - slider_height // 2
                thumb_rect = pygame.Rect(thumb_x, slider_y, slider_height, slider_height)
                pygame.draw.rect(self.screen, RED, thumb_rect, border_radius=10)
                pygame.display.flip()

    def adjust_volume(self, event):
        slider_width = self.volume_slider_rect.width
        mouse_x = event.pos[0]
        self.volume = max(0, min(1, (mouse_x - self.volume_slider_rect.left) / slider_width))
        if self.click_sound:
            self.click_sound.set_volume(self.volume)

    def draw_map(self, map_file="pole", hero_pos=(0, 0), hero_image=None, camera=None):
        try:
            with open(os.path.join(data_dir, map_file), "r") as f:
                map_data = f.read().splitlines()
        except FileNotFoundError:
            print(f"Error: Map file '{map_file}' not found.")
            return

        cell_size = 140

        image1 = None
        image2 = None
        image3 = None

        if map_file == "pole":
            image1 = pygame.image.load(os.path.join(data_dir, "piksel.png")).convert_alpha()
            image2 = pygame.image.load(os.path.join(data_dir, "piksel2.png")).convert_alpha()
            image3 = pygame.image.load(os.path.join(data_dir, "piksel3.png")).convert_alpha()
        elif map_file == "pole2.txt":
            image1 = pygame.image.load(os.path.join(data_dir, "inoplanet_blok.png")).convert_alpha()
            image2 = pygame.image.load(os.path.join(data_dir, "ctarai_ctena.png")).convert_alpha()
            image3 = pygame.image.load(os.path.join(data_dir, "inoplanet_blok_doroga.png")).convert_alpha()
        else:
            print(f"Unknown map file: {map_file}")
            return

        image1 = pygame.transform.scale(image1, (cell_size, cell_size))
        image2 = pygame.transform.scale(image2, (cell_size, cell_size))
        image3 = pygame.transform.scale(image3, (cell_size, cell_size))

        heart_image = pygame.image.load(os.path.join(data_dir, "heart.png")).convert_alpha()
        heart_image = pygame.transform.scale(heart_image, (cell_size, cell_size))

        portal_frames = self.load_portal_frames()

        self.screen.fill((100, 100, 100))

        for row_index, row in enumerate(map_data):
            for col_index, cell_type in enumerate(row):
                x = col_index * cell_size + (camera.dx if camera else 0)
                y = row_index * cell_size + (camera.dy if camera else 0)
                if cell_type == '#':
                    self.screen.blit(image1, (x, y))
                elif cell_type == '*':
                    self.screen.blit(image2, (x, y))
                elif cell_type == '~':
                    self.screen.blit(image3, (x, y))
                elif cell_type == 'h':
                    self.screen.blit(heart_image, (x, y))
                elif cell_type == 'p':
                    current_frame = (pygame.time.get_ticks() // 100) % len(portal_frames)
                    self.screen.blit(portal_frames[current_frame], (x, y))
                elif cell_type == '@':
                    self.screen.blit(image1, (x, y))
                    if (col_index, row_index) == hero_pos and hero_image:
                        hero_x = self.width // 2 - hero_image.get_width() // 2
                        hero_y = self.height // 2 - hero_image.get_height() // 2
                        self.screen.blit(hero_image, (hero_x, hero_y))

    def load_portal_frames(self):
        portal_frames = []
        frame_count = 3
        for i in range(1, frame_count + 1):
            frame = pygame.image.load(os.path.join(data_dir, "portal_frames", f"portal_{i}.png")).convert_alpha()
            frame = pygame.transform.scale(frame, (140, 140))
            portal_frames.append(frame)
        return portal_frames

    def draw_enemy_counter(self):
        font = pygame.font.SysFont(None, 48)
        counter_text = f"{self.killed_enemies}/{self.total_enemies}"
        text_surface = font.render(counter_text, True, WHITE)
        text_rect = text_surface.get_rect(topleft=(20, 20))
        self.screen.blit(text_surface, text_rect)

    def show_game_map(self, selected_character, map_file="pole"):
        pygame.mouse.set_visible(True)
        start_time = pygame.time.get_ticks()
        if self.player_health <= 0:
            self.show_death_screen()
            return
        running = True
        hero_pos = self.find_hero_initial_position(map_file)

        start_time = pygame.time.get_ticks()
        clock = pygame.time.Clock()
        game_map = self.load_map_data(map_file)
        player = self

        if self.saved_hero_pos:
            hero_pos = self.saved_hero_pos
            self.saved_hero_pos = None

        enemy_images = {
            1: pygame.image.load(os.path.join(data_dir, "location_1", "dragon_1.png")).convert_alpha(),
            2: pygame.image.load(os.path.join(data_dir, "pudge.png")).convert_alpha(),
        }

        for key in enemy_images:
            enemy_images[key] = pygame.transform.scale(enemy_images[key], (140, 140))

        enemies = []

        if map_file == "pole2.txt":
            pudge_x, pudge_y = self.get_random_spawn_position(enemies, hero_pos, map_file)
            pudge = Enemy(pudge_x, pudge_y, 2, enemy_images[2], 1, 2, 0.5, self)
            pudge.health = 20
            pudge.attack_damage = 2
            pudge.heal_interval = 10000
            enemies.append(pudge)

        character_image_name = {
            "Немецкий медик": "medic_common.png",
            "Военный Нигерии": "niger_common.png",
            "Русский военный": "test.png"
        }.get(selected_character.name, "default_hero.png")

        try:
            hero_image = pygame.image.load(os.path.join(data_dir, character_image_name)).convert_alpha()
            cell_size = 140
            hero_image = pygame.transform.scale(hero_image, (int(cell_size * 1.3), int(cell_size * 1.3)))
        except pygame.error as e:
            print(f"Error loading hero image: {e}")
            return

        if selected_character.name == "Военный Нигерии":
            self.player_health = 12
            self.player_max_health = 12
        else:
            self.player_health = 10
            self.player_max_health = 10

        if selected_character.name != "Военный Нигерии":
            try:
                patron_image = pygame.image.load(os.path.join(data_dir, "patron.png")).convert_alpha()
                patron_image = pygame.transform.scale(patron_image, (80, 80))
            except pygame.error as e:
                print(f"Error loading patron image: {e}")
                patron_image = None
        else:
            patron_image = None

        enemy_images = {
            1: pygame.image.load(os.path.join(data_dir, "location_1", "dragon_1.png")).convert_alpha(),
            2: pygame.image.load(os.path.join(data_dir, "pudge.png")).convert_alpha(),
        }

        for key in enemy_images:
            enemy_images[key] = pygame.transform.scale(enemy_images[key], (cell_size, cell_size))

        try:
            heart_image = pygame.image.load(os.path.join(data_dir, "heart.png")).convert_alpha()
            heart_image = pygame.transform.scale(heart_image, (50, 50))
        except pygame.error as e:
            print(f"Error loading heart image: {e}")
            heart_image = None

        enemies = []
        fireballs = []
        last_enemy_spawn_time = 0
        enemy_spawn_interval = 3000
        max_enemies = 10

        if map_file == "pole2.txt":
            pudge_x, pudge_y = self.get_random_spawn_position(enemies, hero_pos, map_file)
            pudge = Enemy(pudge_x, pudge_y, 2, enemy_images[2], 1, 2, 0.5, self)
            pudge.health = 20
            pudge.attack_damage = 2
            pudge.heal_interval = 10000
            enemies.append(pudge)
        camera = Camera(self.width, self.height)

        try:
            aim_cursor_image = pygame.image.load(os.path.join(data_dir, "aim.png")).convert_alpha()
            aim_cursor_image = pygame.transform.scale(aim_cursor_image, (80, 80))
        except pygame.error as e:
            print(f"Error loading aim cursor image: {e}")
            aim_cursor_image = None

        reloading = False
        reload_start_time = 0
        reload_duration = 2000

        last_enemy_attack_time = 0
        enemy_attack_interval = 1000

        flipped_image = False

        running = True
        while running:
            delta_time = clock.tick(60) / 1000.0

            current_time = pygame.time.get_ticks()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        self.saved_hero_pos = hero_pos
                        self.saved_game_state = "game_map"
                        running = False
                        self.show_menu_screen()
                    elif event.key == pygame.K_w:
                        hero_pos = self.move_hero(hero_pos, 0, -1, map_file)
                    elif event.key == pygame.K_s:
                        hero_pos = self.move_hero(hero_pos, 0, 1, map_file)
                    elif event.key == pygame.K_a:
                        hero_pos = self.move_hero(hero_pos, -1, 0, map_file)
                        flipped_image = True
                    elif event.key == pygame.K_d:
                        hero_pos = self.move_hero(hero_pos, 1, 0, map_file)
                        flipped_image = False
                    elif event.key == pygame.K_r and not reloading and self.ammo < 10 and selected_character.name != "Военный Нигерии":
                        reloading = True
                        reload_start_time = current_time
                        if self.reload_sound:
                            self.reload_sound.play()
                elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    if selected_character.name == "Военный Нигерии":
                        mouse_x, mouse_y = pygame.mouse.get_pos()
                        for enemy in enemies:
                            enemy_rect = pygame.Rect(enemy.x * cell_size + camera.dx, enemy.y * cell_size + camera.dy,
                                                     cell_size, cell_size)
                            if enemy_rect.collidepoint(mouse_x, mouse_y):
                                if abs(enemy.x - hero_pos[0]) <= 2 and abs(enemy.y - hero_pos[1]) <= 2:
                                    enemy.health -= 1
                                    if enemy.health <= 0:
                                        enemies.remove(enemy)
                                        self.killed_enemies += 1
                                        if enemy.enemy_type == 2:
                                            total_time = (pygame.time.get_ticks() - start_time) // 1000
                                            self.save_game_result(self.killed_enemies, total_time)
                                            self.show_win_screen()
                                            return

                    elif self.ammo > 0 and not reloading:
                        self.ammo -= 1
                        if self.shot_sound:
                            self.shot_sound.play()
                        mouse_x, mouse_y = pygame.mouse.get_pos()
                        for enemy in enemies:
                            enemy_rect = pygame.Rect(enemy.x * cell_size + camera.dx, enemy.y * cell_size + camera.dy,
                                                     cell_size, cell_size)
                            if enemy_rect.collidepoint(mouse_x, mouse_y):
                                enemy.health -= 1
                                if enemy.health <= 0:
                                    enemies.remove(enemy)
                                    self.killed_enemies += 1
                                    if enemy.enemy_type == 2:
                                        total_time = (pygame.time.get_ticks() - start_time) // 1000
                                        self.save_game_result(self.killed_enemies, total_time)
                                        self.show_win_screen()
                                        return
                                break

            camera.update(hero_pos)

            if reloading:
                if current_time - reload_start_time >= reload_duration:
                    self.ammo = 10
                    reloading = False

            if len(enemies) < max_enemies and current_time - last_enemy_spawn_time >= enemy_spawn_interval:
                enemy_type = 1
                x, y = self.get_random_spawn_position(enemies, hero_pos, map_file)
                enemies.append(
                    Enemy(x, y, enemy_type, enemy_images[enemy_type], enemy_type, enemy_type, 0.5, self))
                last_enemy_spawn_time = current_time

            for enemy in enemies:
                enemy.move_towards_hero(hero_pos[0], hero_pos[1], self.load_map_data(map_file), enemies, hero_pos, self)
                enemy.attack(hero_pos[0], hero_pos[1], fireballs)
                enemy.heal()

                if abs(enemy.x - hero_pos[0]) <= 1 and abs(enemy.y - hero_pos[1]) <= 1:
                    if current_time - last_enemy_attack_time >= enemy_attack_interval:
                        self.player_health -= 1
                        last_enemy_attack_time = current_time
                        if self.player_health <= 0:
                            self.show_death_screen()
                            return

            self.screen.fill((0, 128, 0))
            self.draw_map(map_file, hero_pos, hero_image, camera)

            self.draw_enemy_counter()

            hero_x = self.width // 2 - hero_image.get_width() // 2
            hero_y = self.height // 2 - hero_image.get_height() // 2
            displayed_image = pygame.transform.flip(hero_image, flipped_image, False)
            self.screen.blit(displayed_image, (hero_x, hero_y))

            for enemy in enemies:
                enemy_x = enemy.x * cell_size + camera.dx
                enemy_y = enemy.y * cell_size + camera.dy
                self.screen.blit(enemy.image, (enemy_x, enemy_y))

                if heart_image:
                    for i in range(enemy.health):
                        heart_x = enemy_x + i * 60
                        heart_y = enemy_y + cell_size + 10
                        self.screen.blit(heart_image, (heart_x, heart_y))

            if selected_character.name != "Военный Нигерии" and patron_image:
                patron_x = self.width // 2 - 150
                patron_y = self.height - 80
                self.screen.blit(patron_image, (patron_x, patron_y))
                font = pygame.font.SysFont(None, 48)
                ammo_text = font.render(str(self.ammo), True, WHITE)
                text_rect = ammo_text.get_rect(
                    center=(
                        patron_x + patron_image.get_width() // 2, patron_y + patron_image.get_height() // 2 - 10))
                self.screen.blit(ammo_text, text_rect)

            if heart_image:
                for i in range(self.player_max_health):
                    heart_x = self.width // 2 + 100 + i * 60
                    heart_y = self.height - 80
                    if i < self.player_health:
                        self.screen.blit(heart_image, (heart_x, heart_y))
                    else:
                        empty_heart = pygame.Surface((50, 50), pygame.SRCALPHA)
                        empty_heart.blit(heart_image, (0, 0))
                        empty_heart.fill((255, 255, 255, 128), special_flags=pygame.BLEND_RGBA_MULT)
                        self.screen.blit(empty_heart, (heart_x, heart_y))

            mouse_x, mouse_y = pygame.mouse.get_pos()

            cursor_over_enemy = False
            for enemy in enemies:
                enemy_rect = pygame.Rect(enemy.x * cell_size + camera.dx, enemy.y * cell_size + camera.dy,
                                         cell_size, cell_size)
                if enemy_rect.collidepoint(mouse_x, mouse_y):
                    cursor_over_enemy = True
                    break

            if cursor_over_enemy and aim_cursor_image:
                pygame.mouse.set_visible(False)
                self.screen.blit(aim_cursor_image, (mouse_x - 40, mouse_y - 40))
            else:
                pygame.mouse.set_visible(True)

            pygame.display.flip()

    def get_random_spawn_position(self, enemies, hero_pos, map_file="pole"):
        map_data = self.load_map_data(map_file)
        if not map_data:
            print("Error: Map data is empty.")
            return 0, 0

        max_attempts = 100
        for _ in range(max_attempts):
            y = random.randint(0, len(map_data) - 1)

            if not map_data[y]:
                continue

            x = random.randint(0, len(map_data[y]) - 1)

            if map_data[y][x] == '#' and not self.is_cell_occupied(x, y, enemies, hero_pos):
                return x, y

    def load_map_data(self, map_file="pole"):
        try:
            with open(os.path.join(data_dir, map_file), "r") as f:
                map_data = [line.strip() for line in f.readlines() if line.strip()]
                if not map_data:
                    print("Error: Map file 'pole' is empty.")
                return map_data
        except FileNotFoundError:
            print("Error: Map file 'pole' not found.")
            return []

    def find_hero_initial_position(self, map_file="pole"):
        try:
            with open(os.path.join(data_dir, map_file), "r") as f:
                map_data = f.read().splitlines()
        except FileNotFoundError:
            print(f"Error: Map file '{map_file}' not found.")
            return (0, 0)

        for row_index, row in enumerate(map_data):
            for col_index, cell_type in enumerate(row):
                if cell_type == '@':
                    return (col_index, row_index)
        return (0, 0)

    def move_hero(self, hero_pos, dx, dy, map_file="pole"):
        new_x = hero_pos[0] + dx
        new_y = hero_pos[1] + dy

        map_data = self.load_map_data(map_file)
        if not map_data:
            print("Error: Map data is empty.")
            return hero_pos

        if 0 <= new_x < len(map_data[0]) and 0 <= new_y < len(map_data):
            if map_data[new_y][new_x] in ('#', '~', 'h', 'p'):
                if map_data[new_y][new_x] == 'h':
                    self.player_max_health += 1
                    self.player_health = self.player_max_health
                    map_data[new_y] = map_data[new_y][:new_x] + '#' + map_data[new_y][new_x + 1:]
                    self.save_map_data(map_data, map_file)
                elif map_data[new_y][new_x] == 'p':
                    if self.killed_enemies >= self.total_enemies:
                        self.next_level()
                    else:
                        self.show_message("Вы должны убить всех монстров, прежде чем войти в портал!")
                        return hero_pos
                return (new_x, new_y)

        if self.player_health <= 0:
            self.show_death_screen()
            return hero_pos

        return hero_pos

    def next_level(self):
        print("Переход на следующий уровень!")

        self.enemies = []

        self.killed_enemies = 0

        self.show_game_map(self.selected_character, map_file="pole2.txt")

    def save_map_data(self, map_data, map_file="pole"):
        try:
            with open(os.path.join(data_dir, map_file), "w") as f:
                for row in map_data:
                    f.write(row + "\n")
        except Exception as e:
            print(f"Error saving map data: {e}")

    def is_cell_occupied(self, x, y, enemies, hero_pos):
        map_data = self.load_map_data()
        if not map_data:
            print("Error: Map data is empty.")
            return True

        if (x, y) == hero_pos:
            return True
        for enemy in enemies:
            if (enemy.x, enemy.y) == (x, y):
                return True
        return False


class Enemy:
    def __init__(self, x, y, enemy_type, image, attack_range, attack_interval, speed, main_screen):
        self.x = x
        self.y = y
        self.enemy_type = enemy_type
        self.image = image
        self.attack_range = attack_range
        self.attack_interval = attack_interval
        self.speed = speed
        self.last_attack_time = 0
        self.last_move_time = 0
        self.health = 3
        self.attack_damage = 1
        self.heal_interval = 0
        self.last_heal_time = 0
        self.main_screen = main_screen

    def move_towards_hero(self, hero_x, hero_y, map_data, enemies, hero_pos, main_screen):
        current_time = pygame.time.get_ticks()
        if current_time - self.last_move_time >= 1000:
            distance = abs(self.x - hero_x) + abs(self.y - hero_y)
            if distance <= self.attack_range:
                return

            dx = hero_x - self.x
            dy = hero_y - self.y
            if abs(dx) > abs(dy):
                if dx > 0 and self.can_move(self.x + 1, self.y, map_data) and not main_screen.is_cell_occupied(
                        self.x + 1, self.y, enemies, hero_pos):
                    self.x += 1
                elif dx < 0 and self.can_move(self.x - 1, self.y, map_data) and not main_screen.is_cell_occupied(
                        self.x - 1, self.y, enemies, hero_pos):
                    self.x -= 1
            else:
                if dy > 0 and self.can_move(self.x, self.y + 1, map_data) and not main_screen.is_cell_occupied(self.x,
                                                                                                               self.y + 1,
                                                                                                               enemies,
                                                                                                               hero_pos):
                    self.y += 1
                elif dy < 0 and self.can_move(self.x, self.y - 1, map_data) and not main_screen.is_cell_occupied(self.x,
                                                                                                                 self.y - 1,
                                                                                                                 enemies,
                                                                                                                 hero_pos):
                    self.y -= 1
            self.last_move_time = current_time

    def can_move(self, x, y, map_data):
        if 0 <= x < len(map_data[0]) and 0 <= y < len(map_data):
            return map_data[y][x] in ('#', '~')
        return False

    def attack(self, hero_x, hero_y, fireballs):
        current_time = pygame.time.get_ticks()
        if current_time - self.last_attack_time >= self.attack_interval * 1000:
            distance = abs(self.x - hero_x) + abs(self.y - hero_y)
            if distance <= self.attack_range:
                if self.enemy_type == 2:
                    self.main_screen.player_health -= self.attack_damage

    def heal(self):
        if self.heal_interval > 0:
            current_time = pygame.time.get_ticks()
            if current_time - self.last_heal_time >= self.heal_interval:
                self.health = min(self.health + 1, 20)
                self.last_heal_time = current_time


def main():
    pygame.init()
    pygame.mixer.init()
    define_constants()
    infoObject = pygame.display.Info()
    mainscreen = MainScreen(infoObject.current_w, infoObject.current_h)
    mainscreen.run()
    pygame.quit()
    sys.exit()


if __name__ == "__main__":
    main()
