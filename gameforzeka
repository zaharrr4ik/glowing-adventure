import pygame
import random
import os
import sys
import time

class Character:
    def __init__(self, name, image_name, bright_image_name, speed):
        # name: Имя персонажа (строка).
        self.name = name
        # image_name: Имя файла с изображением персонажа (строка).
        self.image_name = image_name
        # bright_image_name: Имя файла с подсвеченным изображением персонажа (строка).
        self.bright_image_name = bright_image_name
        # speed: Скорость передвижения персонажа (число).
        self.speed = speed
        # image: Поверхность Pygame с изображением персонажа. Инициализируется в load_images().
        self.image = None
        # bright_image: Поверхность Pygame с подсвеченным изображением персонажа. Инициализируется в load_images().
        self.bright_image = None
        # rect: Прямоугольник, представляющий область, занимаемую изображением персонажа. Инициализируется в
        # load_images().
        self.rect = None
        # highlighted: Флаг, указывающий, выделен ли персонаж.
        self.highlighted = False


# Создание списка персонажей:
# Список объектов класса Character, представляющих доступных для выбора персонажей.
characters = [
    Character("Немецкий медик", "german_medic.png", "german_medic_bright.png", 5),
    Character("Военный Нигерии", "nigerian_soldier.png", "nigerian_soldier_bright.png", 2),
    Character("Русский военный", "russian_soldier.png", "russian_soldier_bright.png", 3),
]

class Camera:
    def __init__(self, width, height):
        self.dx = 0
        self.dy = 0
        self.width = width  # Ширина экрана
        self.height = height  # Высота экрана

    def update(self, hero_pos):
        """Центрирует камеру на герое."""
        cell_size = 140  # Размер клетки
        self.dx = self.width // 2 - (hero_pos[0] * cell_size + cell_size // 2)
        self.dy = self.height // 2 - (hero_pos[1] * cell_size + cell_size // 2)


class Hero(pygame.sprite.Sprite):
    def __init__(self, image, pos):
        super().__init__()  # Инициализируем Sprite
        self.image = image
        self.rect = self.image.get_rect(topleft=pos)


# Инициализация Pygame
def initialize_pygame():
    pygame.init()
    pygame.mixer.init()

# Определение констант
def define_constants():
    global FPS, WHITE, BLACK, GRAY, YELLOW, RED, data_dir, sounds_dir, GAME_FONT
    FPS = 60
    WHITE = (255, 255, 255)
    BLACK = (0, 0, 0)
    GRAY = (50, 50, 50)
    YELLOW = (255, 255, 0)
    RED = (255, 0, 0)
    data_dir = os.path.join(os.path.dirname(__file__), "data")
    sounds_dir = os.path.join(os.path.dirname(__file__), "sounds")
    GAME_FONT = "comicsansms"

# Класс Character

# Создание списка персонажей
def create_characters():
    return [
        Character("Немецкий медик", "german_medic.png", "german_medic_bright.png", 5),
        Character("Военный Нигерии", "nigerian_soldier.png", "nigerian_soldier_bright.png", 2),
        Character("Русский военный", "russian_soldier.png", "russian_soldier_bright.png", 3),
    ]

# Функция для отрисовки текста
def draw_pixel_text(surface, text, font_size, x, y, color, font):
    font = pygame.font.SysFont(font, font_size)
    text_surface = font.render(text, True, color)
    text_rect = text_surface.get_rect(center=(x, y))
    blurred_surface = pygame.transform.scale(text_surface, (text_surface.get_width() * 2, text_surface.get_height() * 2))
    blurred_surface = pygame.transform.scale(blurred_surface, text_surface.get_size())
    surface.blit(blurred_surface, text_rect)

# Функция для создания текстового поля ввода
def input_box(screen, message, width, height, stars):
    font = pygame.font.Font(None, 36)
    input_rect = pygame.Rect((width - 600) // 2, (height - 50) // 2, 600, 50)
    color_active = pygame.Color('lightskyblue3')
    color_passive = pygame.Color('chartreuse4')
    active = False
    text = ''
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                quit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                active = input_rect.collidepoint(event.pos)
            if event.type == pygame.KEYDOWN:
                if active:
                    if event.key == pygame.K_RETURN:
                        running = False
                    elif event.key == pygame.K_BACKSPACE:
                        text = text[:-1]
                    else:
                        text += event.unicode

        screen.fill(BLACK)
        for star in stars:
            pygame.draw.circle(screen, WHITE, (star[0], star[1]), star[2])
        draw_pixel_text(screen, message, 48, width // 2, input_rect.top - 50, WHITE, font=GAME_FONT)
        color = color_active if active else color_passive
        pygame.draw.rect(screen, color, input_rect, 2)
        text_surface = font.render(text, True, color)
        screen.blit(text_surface, (input_rect.x + 5, input_rect.y + 5))
        pygame.display.flip()
    return text

# Функция для масштабирования изображения

def scale_image(image, scale_factor):
    new_width = int(image.get_width() * scale_factor)
    new_height = int(image.get_height() * scale_factor)
    return pygame.transform.scale(image, (new_width, new_height))

# Функция для создания курсора

def create_cursor(cursor_image):
    try:
        if cursor_image is None:
            print("Warning: Cursor image not loaded correctly.")
            return None, None
        cursor_rect = cursor_image.get_rect()
        return cursor_image, cursor_rect
    except AttributeError as e:
        print(f"Error getting cursor rect: {e}")
        return None, None
    except Exception as e:
        print(f"An unexpected error occurred in create_cursor: {e}")
        return None, None

# Класс MainScreen


class MainScreen:
    def __init__(self, width, height):
        self.volume_slider_rect = None
        self.settings_buttons = None
        self.aim_cursor_rect = None
        self.aim_cursor = None
        self.shot_sound = None
        self.reload_sound = None
        self.walk_sound = None
        self.click_sound = None
        self.character_images = None
        self.width = width
        self.height = height
        self.screen = pygame.display.set_mode((self.width, self.height))
        self.stars = []
        self.generate_stars(200)
        self.load_images()
        self.load_sounds()
        self.player_name = ""
        self.selected_character = None
        self.font = pygame.font.SysFont(None, 64)
        self.buttons = []
        self.volume = 0.5
        self.menu_opened_from_shooting_range = False
        self.previous_test_x = 0
        self.previous_test_y = 0
        self.previous_flipped_image = False
        self.test_x = 0
        self.test_y = 0
        self.flipped_image = False
        self.ammo = 0
        self.camera = Camera(self.width, self.height)  # Создаем камеру
        self.saved_hero_pos = None  # Сохраняем позицию героя
        self.saved_game_state = None  # Сохраняем состояние игры

    def run(self):
        # Останавливаем звук ходьбы, если он играет
        if self.walk_sound and self.walk_sound.get_num_channels() > 0:
            self.walk_sound.stop()

        draw_pixel_text(self.screen, "Сквозь Миры", 150, self.width // 2, self.height // 3, YELLOW, font=GAME_FONT)
        pygame.display.flip()
        time.sleep(3)
        self.screen.fill(BLACK)
        self.show_story()
        self.show_menu_screen()
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        if self.selected_character:
                            self.show_menu_screen()
                        else:
                            self.show_menu_screen()
                    elif event.key == pygame.K_SPACE and self.selected_character is None:
                        self.choose_character()

            if self.selected_character:
                self.show_shooting_range()
            self.draw()
            pygame.display.flip()

        pygame.quit()
        sys.exit()

    def draw_menu_screen(self):
        self.screen.fill(BLACK)
        for star in self.stars:
            pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])

        title_font = pygame.font.SysFont(GAME_FONT, 150)
        title_text = title_font.render("Сквозь Миры", True, (192, 192, 192))
        title_rect = title_text.get_rect(center=(self.width // 2, self.height // 8))
        self.screen.blit(title_text, title_rect)

        menu_font = pygame.font.SysFont(GAME_FONT, 100)
        menu_text = menu_font.render("Меню", True, WHITE)
        menu_rect = menu_text.get_rect(center=(self.width // 2, self.height // 4))
        self.screen.blit(menu_text, menu_rect)

        button_width = self.width // 5
        button_height = 50
        button_x = self.width // 2 - button_width // 2
        button_y_spacing = 20
        button_texts = ["Начать новую игру", "Продолжить игру", "Загрузить игру", "Настройки", "Выйти"]
        self.buttons = []
        for i, text in enumerate(button_texts):
            button_y = menu_rect.bottom + 50 + i * (button_height + button_y_spacing)
            button_rect = pygame.Rect(button_x, button_y, button_width, button_height)
            pygame.draw.rect(self.screen, GRAY, button_rect)
            button_font = pygame.font.SysFont(GAME_FONT, 30)
            button_text = button_font.render(text, True, WHITE)
            button_text_rect = button_text.get_rect(center=button_rect.center)
            self.screen.blit(button_text, button_text_rect)
            self.buttons.append(button_rect)

        pygame.display.flip()

    def generate_stars(self, num_stars):
        for _ in range(num_stars):
            x = random.randint(0, self.width)
            y = random.randint(0, self.height)
            size = random.randint(1, 3)
            self.stars.append([x, y, size])

    def draw(self):
        self.screen.fill(BLACK)
        for star in self.stars:
            pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])
        draw_pixel_text(self.screen, "Сквозь Миры", 100, self.width // 2, 100, WHITE, font=GAME_FONT)
        if self.selected_character:
            draw_pixel_text(self.screen,
                f"Выбран персонаж: {self.selected_character.name}, Имя: {self.player_name}",
                48, self.width // 2, self.height // 2 + 100, WHITE, font=GAME_FONT)

    def load_images(self):
        self.character_images = []
        for char_data in characters:
            try:
                image = pygame.image.load(os.path.join(data_dir, char_data.image_name)).convert_alpha()
                bright_image = pygame.image.load(os.path.join(data_dir, char_data.bright_image_name)).convert_alpha()
                image = scale_image(image, 0.6)
                bright_image = scale_image(bright_image, 0.6)

                # Проверка на успешную загрузку обоих изображений
                if image and bright_image:
                    self.character_images.append(image)
                    char_data.image = image
                    char_data.bright_image = bright_image
                    char_data.rect = image.get_rect()
                else:
                    print(f"Error loading images for {char_data.name}. Skipping character.")

            except pygame.error as e:
                print(f"Error loading images for {char_data.name}: {e}. Skipping character.")

    def load_sounds(self):
        try:
            self.click_sound = pygame.mixer.Sound(os.path.join(sounds_dir, "button_click.wav"))
            self.click_sound.set_volume(0.2)  # Устанавливаем громкость звука
            print("Button click sound loaded successfully.")  # Отладочное сообщение
        except pygame.error as e:
            print(f"Error loading sound file: {e}")
            self.click_sound = None  # Если звук не загружен, устанавливаем значение None

    def show_story(self):
        story_text = [
            "В далеком будущем...",
            "Миры соединяются с помощью таинственных порталов.",
            "Они стремятся разрушить все на своем пути.",
            "Города падут, и надежда угаснет, если не встать на защиту.",
            "Но среди хаоса появляются герои — отважные защитники.",
            "Они готовы сразиться с надвигающейся угрозой.",
            "Объединив силы, герои должны закрыть портал и остановить нашествие.",
            "Судьба человечества висит на волоске.",
            "Приготовьтесь к битве за выживание.",
            "Время действовать настало!"
        ]
        font = pygame.font.SysFont(None, 64)
        y_offset = 200
        text_surfaces = [font.render(line, True, YELLOW) for line in story_text]
        y_positions = [y_offset + i * 70 for i in range(len(text_surfaces))]
        scroll_speed = 1
        all_lines_offscreen = False
        skip_story = False
        running = True
        clock = pygame.time.Clock()

        while running and not all_lines_offscreen:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        skip_story = True
                        break
            if skip_story:
                break

            self.screen.fill(BLACK)
            for star in self.stars:
                pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])
            visible_text = []
            for i, text_surface in enumerate(text_surfaces):
                y_positions[i] -= scroll_speed
                if y_positions[i] + text_surface.get_height() > 0:
                    text_rect = text_surface.get_rect(center=(self.width // 2, y_positions[i]))
                    self.screen.blit(text_surface, text_rect)
                    visible_text.append(text_surface)

            all_lines_offscreen = all(
                y_positions[i] + text_surfaces[i].get_height() <= 0 for i in range(len(text_surfaces)))

            pygame.display.flip()
            clock.tick(30)

    def show_menu_screen(self):
        # Восстановление видимости курсора
        pygame.mouse.set_visible(True)

        # Остальной код меню
        menu_running = True
        self.menu_opened_from_shooting_range = False
        self.test_x = 0
        self.test_y = 0
        self.flipped_image = False
        if self.selected_character:
            self.previous_test_x = self.test_x
            self.previous_test_y = self.test_y
            self.previous_flipped_image = self.flipped_image

        while menu_running:
            self.draw_menu_screen()
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                    menu_running = False
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    for i, rect in enumerate(self.buttons):
                        if rect.collidepoint(event.pos):
                            if self.click_sound:
                                self.click_sound.play()
                            if i == 0:
                                self.choose_character()
                            elif i == 1:
                                menu_running = False
                                if self.saved_game_state == "game_map":
                                    self.show_game_map(self.selected_character)
                                elif self.saved_game_state == "shooting_range":
                                    self.show_shooting_range()
                            elif i == 3:
                                self.show_settings_menu()
                            elif i == 4:
                                self.show_exit_menu()

    # Функция для отображения меню выхода из игры
    def show_exit_menu(self):
        font_title = pygame.font.SysFont(GAME_FONT, 100)
        font_button = pygame.font.SysFont(GAME_FONT, 72)
        button_width = 300
        button_height = 120
        button_spacing = 80

        button1_rect = pygame.Rect((self.width - button_width) // 2,
                                   (self.height // 2) - button_height - button_spacing // 2, button_width,
                                   button_height)
        button2_rect = pygame.Rect((self.width - button_width) // 2, (self.height // 2) + button_spacing // 2,
                                   button_width, button_height)

        exit_menu = True
        while exit_menu:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    quit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if button1_rect.collidepoint(event.pos):
                        if self.click_sound:  # Проверяем, загружен ли звук
                            self.click_sound.play()  # Воспроизводим звук
                        pygame.quit()
                        quit()
                    if button2_rect.collidepoint(event.pos):
                        if self.click_sound:  # Проверяем, загружен ли звук
                            self.click_sound.play()  # Воспроизводим звук
                        exit_menu = False

            self.screen.fill(BLACK)
            for star in self.stars:
                pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])

            title_text = font_title.render("Выйти из игры?", True, WHITE)
            title_rect = title_text.get_rect(center=(self.width // 2, self.height // 4))
            self.screen.blit(title_text, title_rect)

            pygame.draw.rect(self.screen, (80, 80, 200), button1_rect)
            button1_text = font_button.render("Выйти", True, WHITE)
            button1_text_rect = button1_text.get_rect(center=button1_rect.center)
            self.screen.blit(button1_text, button1_text_rect)

            pygame.draw.rect(self.screen, (80, 80, 200), button2_rect)
            button2_text = font_button.render("Остаться", True, WHITE)
            button2_text_rect = button2_text.get_rect(center=button2_rect.center)
            self.screen.blit(button2_text, button2_text_rect)

            pygame.display.flip()

    def choose_character(self):
        selected_character = None
        confirm_button_pressed = False

        while not confirm_button_pressed:
            confirm_button_rect = self.draw_choose_character_screen()  # Рисуем экран и получаем rect кнопки

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

                if event.type == pygame.MOUSEBUTTONDOWN:
                    # Проверяем, нажата ли кнопка "Подтвердить"
                    if confirm_button_rect.collidepoint(event.pos) and selected_character is not None:
                        confirm_button_pressed = True

                    # Проверяем, выбран ли персонаж
                    for i, char in enumerate(characters):
                        if self.character_images[i] and char.rect and char.rect.collidepoint(event.pos):
                            selected_character = char
                            char.highlighted = True
                            for other_char in characters:
                                if other_char != char:
                                    other_char.highlighted = False
                            # Устанавливаем количество пуль в зависимости от выбранного персонажа
                            if selected_character.name == "Немецкий медик":
                                self.ammo = 5  # 5 пуль для Немецкого медика
                            else:
                                self.ammo = 10  # 10 пуль для остальных персонажей

            if confirm_button_pressed and selected_character:
                self.player_name = input_box(self.screen, "Введите имя персонажа:", self.width, self.height, self.stars)
                self.selected_character = selected_character
                self.show_character_intro(selected_character)
                return selected_character

    def draw_choose_character_screen(self):
        self.screen.fill(BLACK)
        for star in self.stars:
            pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])

        if self.character_images:
            try:
                russian_soldier_index = characters.index(
                    next(char for char in characters if char.name == "Русский военный"))
                russian_soldier_image = self.character_images[russian_soldier_index]
            except (StopIteration, ValueError, IndexError):
                print("Error: 'Русский военный' not found or images not loaded properly.")
                return

            spacing = 25
            total_width = sum(img.get_width() for img in self.character_images) + (len(characters) - 1) * spacing
            x_offset = max(0, (self.width - total_width) // 2)

            for i, char in enumerate(characters):
                if self.character_images[i]:
                    try:
                        russian_soldier_index = characters.index(
                            next(c for c in characters if c.name == "Русский военный"))
                        base_height = self.character_images[russian_soldier_index].get_height()
                    except (StopIteration, ValueError, IndexError):
                        print("Error: 'Русский военный' not found or images not loaded properly.")
                        return

                    target_height = base_height
                    aspect_ratio = self.character_images[i].get_width() / self.character_images[i].get_height()
                    new_width = int(target_height * aspect_ratio)

                    scaled_image = pygame.transform.scale(self.character_images[i], (new_width, target_height))
                    scaled_bright_image = pygame.transform.scale(characters[i].bright_image, (new_width, target_height))

                    x_pos = x_offset + sum(img.get_width() for img in self.character_images[:i]) + i * spacing
                    char.rect = pygame.Rect(x_pos, (self.height - target_height) // 2, new_width, target_height)
                    self.screen.blit(scaled_bright_image if char.highlighted else scaled_image, char.rect)

            # Создаем кнопку "Подтвердить"
            button_width = 300
            button_height = 80
            button_x = (self.width - button_width) // 2
            button_y = self.height - 150  # Располагаем кнопку внизу экрана
            confirm_button_rect = pygame.Rect(button_x, button_y, button_width, button_height)

            # Рисуем кнопку
            pygame.draw.rect(self.screen, (80, 80, 200), confirm_button_rect, border_radius=20)
            font = pygame.font.SysFont(None, 48)
            text = font.render("Подтвердить", True, WHITE)
            text_rect = text.get_rect(center=confirm_button_rect.center)
            self.screen.blit(text, text_rect)

            pygame.display.flip()
            return confirm_button_rect

    def show_character_intro(self, selected_character):
        intro_texts = {
            "Немецкий медик": [
                "Вы — опытный немецкий военный медик, оказавшийся втянутым в нечто большее, чем мог представить.",
                f"Вас зовут {self.player_name}, и ваш профессионализм и хладнокровие – ваши главные козыри в этом "
                f"безумии.",
                "Вы прибыли на военную базу в России…"
            ],
            "Военный Нигерии": [
                "Вы — опытный солдат из Нигерии, привыкший к жаре и опасностям своей родины.",
                f"Вас зовут {self.player_name}, но даже ваша выучка не приготовила вас к суровой реальности этого места",
                "Российская военная база стала вашей новой реальностью…"
            ],
            "Русский военный": [
                "Вы — опытный русский военный, привыкший к суровым условиям.",
                f"Вас зовут {self.player_name}, но даже вам предстоит столкнуться с угрозой, превосходящей все ваши ожидания.",
                "Вы находитесь на секретной военной базе в России…"
            ],
        }

        try:
            intro_background = pygame.image.load(os.path.join(data_dir, "intro_background.png")).convert()
            intro_background = pygame.transform.scale(intro_background, (self.width, self.height))
        except pygame.error as e:
            print(f"Error loading intro background: {e}")
            intro_background = None

        font = pygame.font.SysFont(None, 48)
        DARK_GRAY = (50, 50, 50)
        y_offset = 100
        text_surfaces = [font.render(line, True, DARK_GRAY) for line in intro_texts.get(selected_character.name, [])]
        y_positions = [y_offset + i * 70 for i in range(len(text_surfaces))]
        clock = pygame.time.Clock()

        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.KEYDOWN:
                    running = False

            if intro_background:
                self.screen.blit(intro_background, (0, 0))
            else:
                self.screen.fill(BLACK)

            for i, text_surface in enumerate(text_surfaces):
                text_rect = text_surface.get_rect(center=(self.width // 2, y_positions[i]))
                self.screen.blit(text_surface, text_rect)

            pygame.display.flip()
            clock.tick(30)

        self.screen.fill(BLACK)
        self.show_shooting_range()


    def show_shooting_range(self):
        """Displays the shooting range game screen without shooting animation."""
        self.saved_game_state = "shooting_range"
        try:
            # Load resources
            shooting_range_image = pygame.image.load(os.path.join(data_dir, "poligon.png")).convert()
            shooting_range_image = pygame.transform.scale(shooting_range_image, (self.width, self.height))
            target_image = pygame.image.load(os.path.join(data_dir, "target.png")).convert_alpha()
            target_image = pygame.transform.scale(target_image,
                                                  (target_image.get_width() // 2, target_image.get_height() // 2))
            patron_image = pygame.image.load(os.path.join(data_dir, "patron.png")).convert_alpha()
            patron_image = pygame.transform.scale(patron_image,
                                                  (patron_image.get_width() // 2, patron_image.get_height() // 2))
            aim_cursor_image = pygame.image.load(os.path.join(data_dir, "aim.png")).convert_alpha()
            aim_cursor_image = pygame.transform.scale(aim_cursor_image, (
                aim_cursor_image.get_width() // 2, aim_cursor_image.get_height() // 2))

            self.walk_sound = pygame.mixer.Sound(os.path.join(sounds_dir, "dirt_run.wav"))
            self.walk_sound.set_volume(self.volume)
            self.reload_sound = pygame.mixer.Sound(os.path.join(sounds_dir, "reload.wav"))
            self.reload_sound.set_volume(self.volume)
            self.shot_sound = pygame.mixer.Sound(os.path.join(sounds_dir, "shot.wav"))
            self.shot_sound.set_volume(0.1)
            self.sword_sound = pygame.mixer.Sound(os.path.join(sounds_dir, "sword.wav"))  # Звук удара мечом
            self.sword_sound.set_volume(0.5)

            # Load character-specific image
            character_image_name = {
                "Немецкий медик": "medic_common.png",  # Используем medic_common для Немецкого медика
                "Военный Нигерии": "niger_common.png",
                "Русский военный": "test.png"
            }.get(self.selected_character.name)

            if character_image_name is None:
                raise ValueError(f"Image not found for character: {self.selected_character.name}")

            test_image = pygame.image.load(os.path.join(data_dir, character_image_name)).convert_alpha()
            test_image = pygame.transform.scale(test_image, (test_image.get_width() // 2, test_image.get_height() // 2))

            # Initialize test_y AFTER loading test_image
            test_y = self.height - test_image.get_height() - 28

            self.aim_cursor, self.aim_cursor_rect = create_cursor(aim_cursor_image)
            if self.aim_cursor is None:
                pygame.mouse.set_visible(True)

        except (pygame.error, ValueError, FileNotFoundError) as e:
            print(f"Error loading resources: {e}")
            return  # Return to prevent further execution if loading fails

        # Game variables
        test_x = self.test_x
        test_speed = 3
        flipped_image = self.flipped_image
        keys_pressed = {pygame.K_a: False, pygame.K_d: False}
        walk_sound_playing = False
        target_x = self.width - target_image.get_width() - 50
        target_y = self.height - target_image.get_height() - 30
        ammo = self.ammo  # Используем self.ammo, установленное в choose_character
        reloading = False
        reload_start_time = 0
        shooting = False
        shot_start_time = 0
        melee_attacking = False  # Флаг для ближнего боя
        melee_attack_start_time = 0  # Время начала атаки
        bullet_data = []  # Список для хранения данных о пулях: (x, y, время появления)

        # Main game loop
        running = True
        start_time = pygame.time.get_ticks()  # Record start time
        while running:
            current_time = pygame.time.get_ticks()  # Текущее время
            mouse_x, mouse_y = pygame.mouse.get_pos()  # Получаем текущие координаты курсора

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        running = False
                        self.menu_opened_from_shooting_range = True
                        self.show_menu_screen()
                    elif event.key == pygame.K_d:
                        keys_pressed[pygame.K_d] = True
                    elif event.key == pygame.K_a:
                        keys_pressed[pygame.K_a] = True
                    elif event.key == pygame.K_r and not reloading and ammo < 10 and self.selected_character.name != "Военный Нигерии":
                        reloading = True
                        reload_start_time = current_time
                        if self.reload_sound:
                            self.reload_sound.play()
                elif event.type == pygame.KEYUP:
                    if event.key == pygame.K_d:
                        keys_pressed[pygame.K_d] = False
                    elif event.key == pygame.K_a:
                        keys_pressed[pygame.K_a] = False
                elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    if self.selected_character.name == "Военный Нигерии":
                        # Ближний бой для "Военного Нигерии"
                        melee_attacking = True
                        melee_attack_start_time = current_time
                        if self.sword_sound:
                            self.sword_sound.play()
                    elif not reloading and ammo > 0:
                        # Стрельба для других персонажей
                        ammo -= 1
                        shooting = True
                        shot_start_time = current_time
                        if self.shot_sound:
                            self.shot_sound.play()
                        # Добавляем позицию выстрела и время появления
                        bullet_data.append((mouse_x, mouse_y, current_time))

            # Reload handling (только для персонажей, которые могут стрелять)
            if reloading and self.selected_character.name != "Военный Нигерии":
                if current_time - reload_start_time >= 2000:
                    ammo = 10 if self.selected_character.name != "Немецкий медик" else 5  # Восстанавливаем пули в зависимости от персонажа
                    reloading = False

            # Character movement handling
            if keys_pressed[pygame.K_d] or keys_pressed[pygame.K_a]:
                if not walk_sound_playing and self.walk_sound:
                    self.walk_sound.play(-1)
                walk_sound_playing = True
            else:
                if walk_sound_playing and self.walk_sound:
                    self.walk_sound.stop()
                walk_sound_playing = False

            if keys_pressed[pygame.K_d]:
                test_x += test_speed
                flipped_image = False
            elif keys_pressed[pygame.K_a]:
                test_x -= test_speed
                flipped_image = True

            test_x = max(0, min(test_x, self.width - test_image.get_width()))

            # Удаляем пули, которые существуют больше 3 секунд
            bullet_data = [(x, y, spawn_time) for (x, y, spawn_time) in bullet_data if
                           current_time - spawn_time <= 3000]

            # Drawing
            self.screen.fill(BLACK)
            if shooting_range_image:
                self.screen.blit(shooting_range_image, (0, 0))

            displayed_image = pygame.transform.flip(test_image, flipped_image, False)
            self.screen.blit(displayed_image, (test_x, test_y))

            if target_image:
                self.screen.blit(target_image, (target_x, target_y))

            # Отображаем пули только для персонажей, которые могут стрелять
            if self.selected_character.name != "Военный Нигерии":
                if patron_image:
                    patron_x = test_x + test_image.get_width() // 2 - patron_image.get_width() // 2 - 32
                    patron_y = test_y - patron_image.get_height() + 55
                    self.screen.blit(patron_image, (patron_x, patron_y))
                    font = pygame.font.SysFont(None, 36)
                    ammo_text = font.render(str(ammo), True, WHITE)
                    text_rect = ammo_text.get_rect(
                        center=(
                        patron_x + patron_image.get_width() // 2, patron_y + patron_image.get_height() // 2 - 10))
                    self.screen.blit(ammo_text, text_rect)

                # Отрисовка пуль
                for bullet in bullet_data:
                    pygame.draw.circle(self.screen, YELLOW, (bullet[0], bullet[1]), 5)

            # Проверяем, находится ли курсор над мишенью
            target_rect = target_image.get_rect(topleft=(target_x, target_y))
            if target_rect.collidepoint(mouse_x, mouse_y):
                # Скрываем стандартный курсор и отображаем прицел
                pygame.mouse.set_visible(False)
                if self.aim_cursor and self.aim_cursor_rect:
                    # Центрируем прицел на курсоре
                    self.screen.blit(self.aim_cursor, (
                    mouse_x - self.aim_cursor_rect.width // 2, mouse_y - self.aim_cursor_rect.height // 2))
            else:
                # Восстанавливаем стандартный курсор, если курсор не над мишенью
                pygame.mouse.set_visible(True)

            pygame.display.flip()
            elapsed_time = current_time - start_time
            if elapsed_time >= 5000:  # Check if 20 seconds have passed
                self.show_manga()
                running = False  # Exit the loop after showing manga

        # Восстанавливаем стандартный курсор мыши при выходе из игры
        pygame.mouse.set_visible(True)
        self.test_x = test_x
        self.flipped_image = flipped_image

    def show_manga(self):
        # Останавливаем звук ходьбы, если он играет
        if self.walk_sound and self.walk_sound.get_num_channels() > 0:
            self.walk_sound.stop()

        manga_images = ["manga_radio.png", "manga_portal.png", "manga_car.png", "manga_start.png"]
        current_image_index = 0
        running = True

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
                    current_image_index += 1
                    if current_image_index >= len(manga_images):  # Check boundary condition
                        current_image_index = 0  # Loop back to the beginning
                        running = False  # Exit the loop after all images are displayed
                if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                    running = False

            try:
                image_path = os.path.join(data_dir, "manga", manga_images[current_image_index])
                image = pygame.image.load(image_path).convert_alpha()
                image = pygame.transform.scale(image, (self.width, self.height))
                self.screen.blit(image, (0, 0))
                pygame.display.flip()
            except pygame.error as e:
                print(f"Error loading manga image: {e}")
                running = False  # Exit if an image can't be loaded

        self.show_game_map(self.selected_character)

    def show_settings_menu(self):
        running = True
        self.dragging_slider = False

        while running:
            self.screen.fill(BLACK)
            for star in self.stars:
                pygame.draw.circle(self.screen, WHITE, (star[0], star[1]), star[2])
            title_font = pygame.font.SysFont(GAME_FONT, 100)
            title_text = title_font.render("Настройки", True, RED)
            title_rect = title_text.get_rect(center=(self.width // 2, self.height // 4))
            self.screen.blit(title_text, title_rect)

            button_width = self.width // 5
            button_height = 60
            button_x = self.width // 2 - button_width // 2
            button_y_spacing = 30

            button_texts = ["Назад", "Применить"]
            self.settings_buttons = []

            for i, text in enumerate(button_texts):
                button_y = title_rect.bottom + 50 + i * (button_height + button_y_spacing)
                button_rect = pygame.Rect(button_x, button_y, button_width, button_height)
                pygame.draw.rect(self.screen, GRAY, button_rect)
                button_font = pygame.font.SysFont(GAME_FONT, 30)
                button_text = button_font.render(text, True, WHITE)
                button_text_rect = button_text.get_rect(center=button_rect.center)
                self.screen.blit(button_text, button_text_rect)
                self.settings_buttons.append(button_rect)

            slider_width = 300
            slider_height = 40
            slider_x = self.width // 2 - slider_width // 2
            slider_y = title_rect.bottom + 50 + 2 * (button_height + button_y_spacing) + 30

            self.volume_slider_rect = pygame.Rect(slider_x, slider_y, slider_width, slider_height)
            pygame.draw.rect(self.screen, GRAY, self.volume_slider_rect, border_radius=10)

            thumb_x = slider_x + int(self.volume * slider_width) - slider_height // 2
            thumb_rect = pygame.Rect(thumb_x, slider_y, slider_height, slider_height)
            pygame.draw.rect(self.screen, RED, thumb_rect, border_radius=10)

            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    for i, rect in enumerate(self.settings_buttons):
                        if rect.collidepoint(event.pos):
                            if self.click_sound:
                                self.click_sound.play()
                            if i == 0:
                                running = False
                            elif i == 1:
                                pass
                    if self.volume_slider_rect.collidepoint(event.pos):
                        self.dragging_slider = True
                        self.adjust_volume(event)
                elif event.type == pygame.MOUSEBUTTONUP:
                    self.dragging_slider = False
                elif event.type == pygame.MOUSEMOTION:
                    if self.dragging_slider:
                        self.adjust_volume(event)

                thumb_x = slider_x + int(self.volume * slider_width) - slider_height // 2
                thumb_rect = pygame.Rect(thumb_x, slider_y, slider_height, slider_height)
                pygame.draw.rect(self.screen, RED, thumb_rect, border_radius=10)
                pygame.display.flip()

    def adjust_volume(self, event):
        slider_width = self.volume_slider_rect.width
        mouse_x = event.pos[0]
        self.volume = max(0, min(1, (mouse_x - self.volume_slider_rect.left) / slider_width))
        if self.click_sound:
            self.click_sound.set_volume(self.volume)

    def draw_map(self, map_file="pole", hero_pos=(0, 0), hero_image=None, camera=None):
        try:
            with open(os.path.join(data_dir, map_file), "r") as f:
                map_data = f.read().splitlines()
        except FileNotFoundError:
            print(f"Error: Map file '{map_file}' not found.")
            return

        cell_size = 140  # Размер клетки

        # Загрузка изображений с прозрачностью и масштабированием
        image1 = pygame.image.load(os.path.join(data_dir, "piksel.png")).convert_alpha()
        image1 = pygame.transform.scale(image1, (cell_size, cell_size))

        image2 = pygame.image.load(os.path.join(data_dir, "piksel2.png")).convert_alpha()
        image2 = pygame.transform.scale(image2, (cell_size, cell_size))

        image3 = pygame.image.load(os.path.join(data_dir, "piksel3.png")).convert_alpha()  # Новая клетка
        image3 = pygame.transform.scale(image3, (cell_size, cell_size))

        # Очистка экрана
        self.screen.fill((100, 100, 100))  # Серый цвет фона

        # Отрисовка карты
        for row_index, row in enumerate(map_data):
            for col_index, cell_type in enumerate(row):
                x = col_index * cell_size + (camera.dx if camera else 0)
                y = row_index * cell_size + (camera.dy if camera else 0)
                if cell_type == '#':  # Проходимая клетка
                    self.screen.blit(image1, (x, y))
                elif cell_type == '*':  # Непроходимая стена
                    self.screen.blit(image2, (x, y))
                elif cell_type == '~':  # Новая клетка
                    self.screen.blit(image3, (x, y))
                elif cell_type == '@':  # Начальная позиция героя
                    self.screen.blit(image1, (x, y))
                    if (col_index, row_index) == hero_pos and hero_image:
                        # Центрируем героя на экране
                        hero_x = self.width // 2 - hero_image.get_width() // 2
                        hero_y = self.height // 2 - hero_image.get_height() // 2
                        self.screen.blit(hero_image, (hero_x, hero_y))

    def show_game_map(self, selected_character):
        running = True
        hero_pos = self.find_hero_initial_position()

        if self.saved_hero_pos:
            hero_pos = self.saved_hero_pos
            self.saved_hero_pos = None

        # Загрузка изображения персонажа
        character_image_name = {
            "Немецкий медик": "medic_common.png",
            "Военный Нигерии": "niger_common.png",
            "Русский военный": "test.png"
        }.get(selected_character.name, "default_hero.png")

        try:
            hero_image = pygame.image.load(os.path.join(data_dir, character_image_name)).convert_alpha()
            cell_size = 140
            hero_image = pygame.transform.scale(hero_image, (int(cell_size * 1.3), int(cell_size * 1.3)))
        except pygame.error as e:
            print(f"Error loading hero image: {e}")
            return

        # Загрузка изображения патронов
        try:
            patron_image = pygame.image.load(os.path.join(data_dir, "patron.png")).convert_alpha()
            patron_image = pygame.transform.scale(patron_image, (80, 80))  # Увеличиваем размер патронов
        except pygame.error as e:
            print(f"Error loading patron image: {e}")
            patron_image = None

        # Загрузка изображений врагов
        enemy_images = {
            1: pygame.image.load(os.path.join(data_dir, "location_1", "dragon_1.png")).convert_alpha(),
        }
        for key in enemy_images:
            enemy_images[key] = pygame.transform.scale(enemy_images[key], (cell_size, cell_size))

        # Загрузка изображения сердца
        try:
            heart_image = pygame.image.load(os.path.join(data_dir, "heart.png")).convert_alpha()
            heart_image = pygame.transform.scale(heart_image, (50, 50))  # Увеличиваем размер сердечек
        except pygame.error as e:
            print(f"Error loading heart image: {e}")
            heart_image = None

        # Здоровье игрока (10 сердечек)
        player_health = 10

        # Инициализация врагов
        enemies = []
        fireballs = []
        last_enemy_spawn_time = 0
        enemy_spawn_interval = 3000  # 3 секунды
        max_enemies = 10

        # Инициализация камеры
        camera = Camera(self.width, self.height)

        # Загрузка изображения прицела
        try:
            aim_cursor_image = pygame.image.load(os.path.join(data_dir, "aim.png")).convert_alpha()
            aim_cursor_image = pygame.transform.scale(aim_cursor_image, (80, 80))  # Увеличиваем размер прицела
        except pygame.error as e:
            print(f"Error loading aim cursor image: {e}")
            aim_cursor_image = None

        # Перезарядка
        reloading = False
        reload_start_time = 0
        reload_duration = 2000  # 2 секунды на перезарядку

        # Время последнего удара монстра
        last_enemy_attack_time = 0
        enemy_attack_interval = 1000  # 1 секунда между ударами

        # Желтые точки от попаданий
        bullet_data = []  # Список для хранения данных о пулях: (x, y, время появления)

        while running:
            current_time = pygame.time.get_ticks()

            # Обработка событий
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        self.saved_hero_pos = hero_pos
                        self.saved_game_state = "game_map"
                        running = False
                        self.show_menu_screen()
                    elif event.key == pygame.K_w:
                        hero_pos = self.move_hero(hero_pos, 0, -1)
                    elif event.key == pygame.K_s:
                        hero_pos = self.move_hero(hero_pos, 0, 1)
                    elif event.key == pygame.K_a:
                        hero_pos = self.move_hero(hero_pos, -1, 0)
                    elif event.key == pygame.K_d:
                        hero_pos = self.move_hero(hero_pos, 1, 0)
                    elif event.key == pygame.K_r and not reloading and self.ammo < 10:  # Перезарядка
                        reloading = True
                        reload_start_time = current_time
                        if self.reload_sound:
                            self.reload_sound.play()
                elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:  # Левая кнопка мыши
                    if self.ammo > 0 and not reloading:
                        self.ammo -= 1
                        if self.shot_sound:
                            self.shot_sound.play()  # Звук стрельбы
                        # Добавляем позицию выстрела и время появления
                        mouse_x, mouse_y = pygame.mouse.get_pos()
                        bullet_data.append((mouse_x, mouse_y, current_time))
                        # Проверяем, попал ли выстрел во врага
                        for enemy in enemies:
                            enemy_rect = pygame.Rect(enemy.x * cell_size + camera.dx, enemy.y * cell_size + camera.dy,
                                                     cell_size, cell_size)
                            if enemy_rect.collidepoint(mouse_x, mouse_y):
                                enemy.health -= 1  # Уменьшаем здоровье врага
                                if enemy.health <= 0:
                                    enemies.remove(enemy)  # Удаляем врага, если здоровье закончилось
                                break

            # Обновление камеры
            camera.update(hero_pos)

            # Перезарядка
            if reloading:
                if current_time - reload_start_time >= reload_duration:
                    self.ammo = 10  # Восстанавливаем патроны
                    reloading = False

            # Спавн врагов
            if len(enemies) < max_enemies and current_time - last_enemy_spawn_time >= enemy_spawn_interval:
                enemy_type = 1  # Только ближний бой
                x, y = self.get_random_spawn_position(enemies, hero_pos)
                enemies.append(Enemy(x, y, enemy_type, enemy_images[enemy_type], enemy_type, enemy_type, 0.5))
                last_enemy_spawn_time = current_time

            # Обновление врагов
            for enemy in enemies:
                enemy.move_towards_hero(hero_pos[0], hero_pos[1], self.load_map_data(), enemies, hero_pos, self)
                enemy.attack(hero_pos[0], hero_pos[1], fireballs)

                # Проверяем, находится ли враг рядом с игроком
                if abs(enemy.x - hero_pos[0]) <= 1 and abs(enemy.y - hero_pos[1]) <= 1:
                    if current_time - last_enemy_attack_time >= enemy_attack_interval:
                        player_health -= 1  # Уменьшаем здоровье игрока на 1 сердечко
                        last_enemy_attack_time = current_time
                        if player_health <= 0:
                            print("Игрок погиб!")
                            running = False

            # Удаляем пули, которые существуют больше 3 секунд
            bullet_data = [(x, y, spawn_time) for (x, y, spawn_time) in bullet_data if
                           current_time - spawn_time <= 3000]

            # Отрисовка карты, врагов и огненных шаров
            self.screen.fill((100, 100, 100))  # Очистка экрана
            self.draw_map(hero_pos=hero_pos, hero_image=hero_image, camera=camera)

            # Отрисовка героя
            hero_x = self.width // 2 - hero_image.get_width() // 2  # Центрируем героя
            hero_y = self.height // 2 - hero_image.get_height() // 2
            self.screen.blit(hero_image, (hero_x, hero_y))

            for enemy in enemies:
                enemy_x = enemy.x * cell_size + camera.dx
                enemy_y = enemy.y * cell_size + camera.dy
                self.screen.blit(enemy.image, (enemy_x, enemy_y))

                # Отрисовка здоровья врага (3 сердечка)
                if heart_image:
                    for i in range(enemy.health):
                        heart_x = enemy_x + i * 60  # Увеличиваем расстояние между сердечками
                        heart_y = enemy_y + cell_size + 10
                        self.screen.blit(heart_image, (heart_x, heart_y))

            # Отрисовка патронов
            if patron_image:
                patron_x = self.width // 2 - 150  # Позиция патронов по центру внизу
                patron_y = self.height - 80
                self.screen.blit(patron_image, (patron_x, patron_y))
                font = pygame.font.SysFont(None, 48)  # Увеличиваем размер шрифта
                ammo_text = font.render(str(self.ammo), True, WHITE)
                text_rect = ammo_text.get_rect(
                    center=(patron_x + patron_image.get_width() // 2, patron_y + patron_image.get_height() // 2 - 10))
                self.screen.blit(ammo_text, text_rect)

            # Отрисовка здоровья игрока (10 сердечек)
            if heart_image:
                for i in range(player_health):
                    heart_x = self.width // 2 + 100 + i * 60  # Увеличиваем расстояние между сердечками
                    heart_y = self.height - 80
                    self.screen.blit(heart_image, (heart_x, heart_y))

            # Отрисовка желтых точек от попаданий
            for bullet in bullet_data:
                pygame.draw.circle(self.screen, YELLOW, (bullet[0], bullet[1]), 5)

            # Получаем позицию курсора мыши
            mouse_x, mouse_y = pygame.mouse.get_pos()

            # Проверяем, находится ли курсор над врагом
            cursor_over_enemy = False
            for enemy in enemies:
                enemy_rect = pygame.Rect(enemy.x * cell_size + camera.dx, enemy.y * cell_size + camera.dy, cell_size,
                                         cell_size)
                if enemy_rect.collidepoint(mouse_x, mouse_y):
                    cursor_over_enemy = True
                    break

            # Отображаем прицел, если курсор над врагом
            if cursor_over_enemy and aim_cursor_image:
                pygame.mouse.set_visible(False)
                self.screen.blit(aim_cursor_image, (mouse_x - 40, mouse_y - 40))  # Центрируем прицел
            else:
                pygame.mouse.set_visible(True)

            pygame.display.flip()
            
    def get_random_spawn_position(self, enemies, hero_pos):
        """Возвращает случайную позицию для спавна врага, которая не занята."""
        map_data = self.load_map_data()
        if not map_data:
            print("Error: Map data is empty.")
            return 0, 0  # Возвращаем начальную позицию, если карта не загружена

        max_attempts = 100  # Максимальное количество попыток для поиска свободной клетки
        for _ in range(max_attempts):
            y = random.randint(0, len(map_data) - 1)  # Генерация y в пределах высоты карты

            # Проверяем, что строка карты не пустая
            if not map_data[y]:
                continue

            x = random.randint(0, len(map_data[y]) - 1)  # Генерация x в пределах длины строки y

            # Проверяем, что клетка проходима и не занята
            if map_data[y][x] == '#' and not self.is_cell_occupied(x, y, enemies, hero_pos):
                return x, y


    def load_map_data(self):
        """Загружает данные карты из файла."""
        try:
            with open(os.path.join(data_dir, "pole"), "r") as f:
                map_data = [line.strip() for line in f.readlines() if line.strip()]  # Игнорируем пустые строки
                if not map_data:
                    print("Error: Map file 'pole' is empty.")
                return map_data
        except FileNotFoundError:
            print("Error: Map file 'pole' not found.")
            return []

    def find_hero_initial_position(self, map_file="pole"):
        try:
            with open(os.path.join(data_dir, map_file), "r") as f:
                map_data = f.read().splitlines()
        except FileNotFoundError:
            print(f"Error: Map file '{map_file}' not found.")
            return (0, 0)  # Возвращаем начальную позицию (0, 0), если файл не найден

        for row_index, row in enumerate(map_data):
            for col_index, cell_type in enumerate(row):
                if cell_type == '@':
                    return (col_index, row_index)  # Возвращаем координаты героя
        return (0, 0)  # Если символ '@' не найден, возвращаем (0, 0)

    def move_hero(self, hero_pos, dx, dy):
        """Перемещает героя на (dx, dy) клеток, если это возможно."""
        new_x = hero_pos[0] + dx
        new_y = hero_pos[1] + dy

        map_data = self.load_map_data()
        if not map_data:
            print("Error: Map data is empty.")
            return hero_pos

        # Проверяем, что новая позиция находится в пределах карты и проходима
        if 0 <= new_x < len(map_data[0]) and 0 <= new_y < len(map_data):
            if map_data[new_y][new_x] in ('#', '~'):  # Клетка проходима
                return (new_x, new_y)
        return hero_pos  # Если движение невозможно, возвращаем старую позицию

    def is_cell_occupied(self, x, y, enemies, hero_pos):
        """Проверяет, занята ли клетка (x, y) врагами или героем."""
        map_data = self.load_map_data()
        if not map_data:
            print("Error: Map data is empty.")
            return True

        # Проверяем, не находится ли герой в этой клетке
        if (x, y) == hero_pos:
            return True
        # Проверяем, не находится ли в этой клетке враг
        for enemy in enemies:
            if (enemy.x, enemy.y) == (x, y):
                return True
        return False



class Enemy:
    def __init__(self, x, y, enemy_type, image, attack_range, attack_interval, speed):
        self.x = x
        self.y = y
        self.enemy_type = enemy_type
        self.image = image
        self.attack_range = attack_range
        self.attack_interval = attack_interval
        self.speed = speed
        self.last_attack_time = 0
        self.last_move_time = 0
        self.health = 3  # Здоровье врага (3 сердечка)

    def move_towards_hero(self, hero_x, hero_y, map_data, enemies, hero_pos, main_screen):
        """Двигается к герою, если это возможно, избегая занятых клеток."""
        current_time = pygame.time.get_ticks()
        if current_time - self.last_move_time >= 1000:  # Движение каждую секунду
            distance = abs(self.x - hero_x) + abs(self.y - hero_y)
            # Если враг уже на дистанции атаки, он не двигается ближе
            if distance <= self.attack_range:
                return

            dx = hero_x - self.x
            dy = hero_y - self.y
            if abs(dx) > abs(dy):
                if dx > 0 and self.can_move(self.x + 1, self.y, map_data) and not main_screen.is_cell_occupied(self.x + 1, self.y, enemies, hero_pos):
                    self.x += 1
                elif dx < 0 and self.can_move(self.x - 1, self.y, map_data) and not main_screen.is_cell_occupied(self.x - 1, self.y, enemies, hero_pos):
                    self.x -= 1
            else:
                if dy > 0 and self.can_move(self.x, self.y + 1, map_data) and not main_screen.is_cell_occupied(self.x, self.y + 1, enemies, hero_pos):
                    self.y += 1
                elif dy < 0 and self.can_move(self.x, self.y - 1, map_data) and not main_screen.is_cell_occupied(self.x, self.y - 1, enemies, hero_pos):
                    self.y -= 1
            self.last_move_time = current_time

    def can_move(self, x, y, map_data):
        """Проверяет, может ли враг переместиться на клетку (x, y)."""
        if 0 <= x < len(map_data[0]) and 0 <= y < len(map_data):
            return map_data[y][x] == '#'
        return False

    def attack(self, hero_x, hero_y, fireballs):
        """Атакует героя, если он в зоне досягаемости."""
        current_time = pygame.time.get_ticks()
        if current_time - self.last_attack_time >= self.attack_interval * 1000:
            distance = abs(self.x - hero_x) + abs(self.y - hero_y)
            if distance <= self.attack_range:
                if self.enemy_type == 2:  # Дальний бой
                    fireballs.append(Fireball(self.x, self.y, hero_x, hero_y))
                self.last_attack_time = current_time

class Fireball:
    def __init__(self, start_x, start_y, target_x, target_y):
        self.x = start_x  # Начальная позиция X
        self.y = start_y  # Начальная позиция Y
        self.target_x = target_x  # Целевая позиция X
        self.target_y = target_y  # Целевая позиция Y
        self.speed = 1  # Скорость движения (1 клетка в секунду)
        self.image = pygame.image.load(os.path.join(data_dir, "location_1", "ball.png")).convert_alpha()
        self.image = pygame.transform.scale(self.image, (40, 40))  # Масштабирование изображения

        # Определяем направление движения (горизонтальное или вертикальное)
        if abs(self.target_x - self.x) > abs(self.target_y - self.y):
            # Движение по горизонтали
            self.direction = 'horizontal'
            self.dx = 1 if self.target_x > self.x else -1
            self.dy = 0
        else:
            # Движение по вертикали
            self.direction = 'vertical'
            self.dx = 0
            self.dy = 1 if self.target_y > self.y else -1

    def update(self):
        """Обновляет позицию огненного шара."""
        self.x += self.dx * self.speed
        self.y += self.dy * self.speed

    def collides_with_hero(self, hero_x, hero_y):
        """Проверяет, попал ли огненный шар в героя."""
        return abs(self.x - hero_x) < 1 and abs(self.y - hero_y) < 1


# Основной код
def main():
    pygame.init()  # Инициализация Pygame
    pygame.mixer.init()  # Инициализация звуковой системы
    define_constants()
    infoObject = pygame.display.Info()
    mainscreen = MainScreen(infoObject.current_w, infoObject.current_h)
    mainscreen.run()
    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
